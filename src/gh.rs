//! GitHub CLI (gh) integration for PR operations
//!
//! This module provides functions to interact with the GitHub CLI for
//! checking prerequisites and managing pull requests.

use crate::error::Result;
use crate::git::{self, PushResult};
use crate::output::{print_push_already_up_to_date, print_push_success, print_pushing_branch};
use crate::spec::Spec;
use std::process::Command;

/// Result type for PR creation operations
///
/// Captures all possible outcomes of the PR creation step.
/// Note that `Skipped` represents a successful state transition (not a failure)
/// when prerequisites aren't met.
#[derive(Debug, Clone, PartialEq)]
pub enum PRResult {
    /// PR created successfully, contains PR URL
    Success(String),
    /// Prerequisites not met, contains reason for skip
    Skipped(String),
    /// PR already exists for branch, contains existing PR URL
    AlreadyExists(String),
    /// PR description updated successfully, contains PR URL
    Updated(String),
    /// PR creation attempted but failed, contains error message
    Error(String),
}

/// Maximum length for PR titles (GitHub standard)
const PR_TITLE_MAX_LENGTH: usize = 72;

/// Format a Spec into a concise PR title
///
/// The title is generated by:
/// 1. Taking the first line or sentence of the description
/// 2. Truncating to 72 characters (GitHub standard) with "..." if longer
/// 3. Optionally prefixing with `[project]` if the spec has a project field
///
/// The full description remains in the PR body summary section.
pub fn format_pr_title(spec: &Spec) -> String {
    // Extract the first line or first sentence from the description
    let first_part = extract_first_line_or_sentence(&spec.description);

    // Build title with optional project prefix
    let title = if spec.project.is_empty() {
        first_part
    } else {
        format!("[{}] {}", spec.project, first_part)
    };

    // Truncate to max length with ellipsis if needed
    truncate_with_ellipsis(&title, PR_TITLE_MAX_LENGTH)
}

/// Extract the first line or first sentence from text
///
/// Returns the first line if the text is multi-line, or the first sentence
/// (ending in '.', '!', or '?') if single-line. Falls back to the whole text
/// if no sentence boundary is found.
fn extract_first_line_or_sentence(text: &str) -> String {
    // First, try to get the first line if multi-line
    if let Some(newline_pos) = text.find('\n') {
        let first_line = text[..newline_pos].trim();
        if !first_line.is_empty() {
            return first_line.to_string();
        }
    }

    // For single-line text, try to extract the first sentence
    // Look for sentence-ending punctuation followed by space or end of string
    for (i, c) in text.char_indices() {
        if c == '.' || c == '!' || c == '?' {
            // Check if this is followed by a space or end of string
            let next_idx = i + c.len_utf8();
            if next_idx >= text.len() || text[next_idx..].starts_with(' ') {
                let sentence = text[..=i].trim();
                if !sentence.is_empty() {
                    return sentence.to_string();
                }
            }
        }
    }

    // Fallback: return the whole text trimmed
    text.trim().to_string()
}

/// Truncate a string to a maximum length, adding "..." if truncated
///
/// Truncates at word boundaries when possible to avoid cutting words.
fn truncate_with_ellipsis(text: &str, max_len: usize) -> String {
    if text.len() <= max_len {
        return text.to_string();
    }

    // Reserve space for "..."
    let target_len = max_len - 3;

    // Try to find a word boundary (space) to truncate at
    let truncate_at = text[..target_len].rfind(' ').unwrap_or(target_len);

    format!("{}...", text[..truncate_at].trim_end())
}

/// Format a Spec into a well-structured GitHub PR description in Markdown format
///
/// The output includes:
/// - A Summary section with the spec description
/// - Stories separated by completion status:
///   - "## Completed" section for stories with `passes: true`
///   - "## Remaining" section for stories with `passes: false` (only if completed stories exist)
///   - "## Changes" section if no stories are complete (shows all stories)
///
/// Acceptance criteria are rendered as GitHub-flavored markdown checkboxes:
/// - Completed stories (`passes: true`) show checked boxes: `- [x] Criterion`
/// - Incomplete stories show unchecked boxes: `- [ ] Criterion`
pub fn format_pr_description(spec: &Spec) -> String {
    let mut output = String::new();

    // Summary section
    output.push_str("## Summary\n\n");
    output.push_str(&spec.description);
    output.push_str("\n\n");

    // Partition stories by completion status
    let completed: Vec<_> = spec.user_stories.iter().filter(|s| s.passes).collect();
    let incomplete: Vec<_> = spec.user_stories.iter().filter(|s| !s.passes).collect();

    if completed.is_empty() {
        // No completed stories: show all under "Changes"
        output.push_str("## Changes\n\n");
        for story in &spec.user_stories {
            format_story(&mut output, story);
        }
    } else {
        // Has completed stories: show "Completed" section
        output.push_str("## Completed\n\n");
        for story in &completed {
            format_story(&mut output, story);
        }

        // Only show "Remaining" if there are incomplete stories
        if !incomplete.is_empty() {
            output.push_str("## Remaining\n\n");
            for story in &incomplete {
                format_story(&mut output, story);
            }
        }
    }

    // Trim trailing whitespace but keep one trailing newline
    output.trim_end().to_string()
}

/// Format a single user story for the PR description
fn format_story(output: &mut String, story: &crate::spec::UserStory) {
    // Format: ### US-001: [title]
    output.push_str(&format!("### {}: {}\n\n", story.id, story.title));
    output.push_str(&story.description);
    output.push_str("\n\n");

    // Add acceptance criteria as checkboxes if present
    if !story.acceptance_criteria.is_empty() {
        output.push_str("**Acceptance Criteria:**\n\n");
        let checkbox = if story.passes { "[x]" } else { "[ ]" };
        for criterion in &story.acceptance_criteria {
            output.push_str(&format!("- {} {}\n", checkbox, criterion));
        }
        output.push('\n');
    }

    // Add notes if present
    if !story.notes.is_empty() {
        output.push_str("**Notes:**\n\n");
        output.push_str(&story.notes);
        output.push_str("\n\n");
    }
}

/// Check if the GitHub CLI (gh) is installed and available in PATH
pub fn is_gh_installed() -> bool {
    Command::new("gh")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Check if the user is authenticated with GitHub CLI
///
/// Uses `gh auth status` which returns exit code 0 if authenticated.
pub fn is_gh_authenticated() -> bool {
    Command::new("gh")
        .args(["auth", "status"])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Check if a pull request already exists for the given branch
///
/// Returns `Ok(true)` if a PR exists, `Ok(false)` if no PR exists,
/// or an error if the command fails.
pub fn pr_exists_for_branch(branch: &str) -> Result<bool> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "number"])
        .output()?;

    if !output.status.success() {
        // On error, return false (non-blocking behavior)
        return Ok(false);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array [] means no PRs exist
    // Non-empty array means at least one PR exists
    Ok(trimmed != "[]" && !trimmed.is_empty())
}

/// Get the URL of an existing pull request for the given branch
///
/// Returns `Ok(Some(url))` if a PR exists, `Ok(None)` if no PR exists,
/// or an error if the command fails.
pub fn get_existing_pr_url(branch: &str) -> Result<Option<String>> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "url"])
        .output()?;

    if !output.status.success() {
        // On error, return None (non-blocking behavior)
        return Ok(None);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(None);
    }

    // Parse JSON array to extract URL
    // Expected format: [{"url":"https://github.com/..."}]
    let parsed: std::result::Result<Vec<serde_json::Value>, _> = serde_json::from_str(trimmed);

    match parsed {
        Ok(prs) if !prs.is_empty() => {
            if let Some(url) = prs[0].get("url").and_then(|v| v.as_str()) {
                Ok(Some(url.to_string()))
            } else {
                Ok(None)
            }
        }
        _ => Ok(None),
    }
}

/// Get the PR number for an existing pull request for the given branch
///
/// Returns `Ok(Some(number))` if a PR exists, `Ok(None)` if no PR exists,
/// or an error if the command fails.
pub fn get_existing_pr_number(branch: &str) -> Result<Option<u32>> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "number"])
        .output()?;

    if !output.status.success() {
        // On error, return None (non-blocking behavior)
        return Ok(None);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(None);
    }

    // Parse JSON array to extract number
    // Expected format: [{"number":123}]
    let parsed: std::result::Result<Vec<serde_json::Value>, _> = serde_json::from_str(trimmed);

    match parsed {
        Ok(prs) if !prs.is_empty() => {
            if let Some(number) = prs[0].get("number").and_then(|v| v.as_u64()) {
                Ok(Some(number as u32))
            } else {
                Ok(None)
            }
        }
        _ => Ok(None),
    }
}

/// Update the description of an existing pull request
///
/// Uses `gh pr edit <number> --body <new_body>` to update the PR description.
///
/// # Arguments
/// * `spec` - The spec containing PR description data
/// * `pr_number` - The PR number to update
///
/// # Returns
/// * `PRResult::Updated(url)` - PR updated successfully
/// * `PRResult::Error(message)` - PR update failed
pub fn update_pr_description(spec: &Spec, pr_number: u32) -> Result<PRResult> {
    let body = format_pr_description(spec);

    let output = Command::new("gh")
        .args(["pr", "edit", &pr_number.to_string(), "--body", &body])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(PRResult::Error(format!(
            "Failed to update PR: {}",
            stderr.trim()
        )));
    }

    // Get the PR URL for the success message
    let url_output = Command::new("gh")
        .args(["pr", "view", &pr_number.to_string(), "--json", "url"])
        .output()?;

    if url_output.status.success() {
        let stdout = String::from_utf8_lossy(&url_output.stdout);
        if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(stdout.trim()) {
            if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                return Ok(PRResult::Updated(url.to_string()));
            }
        }
    }

    // Fallback: construct URL from PR number (not ideal but functional)
    Ok(PRResult::Updated(format!("PR #{}", pr_number)))
}

/// Create a pull request for the current branch using the GitHub CLI
///
/// This function orchestrates all prerequisite checks and PR creation.
/// It returns `PRResult::Skipped` (not an error) when prerequisites aren't met,
/// allowing the workflow to continue gracefully.
///
/// # Arguments
/// * `spec` - The spec containing PR title and description data
/// * `commits_were_made` - Whether commits were made in the current session
///
/// # Returns
/// * `PRResult::Success(url)` - PR created successfully
/// * `PRResult::Skipped(reason)` - Prerequisites not met
/// * `PRResult::AlreadyExists(url)` - PR already exists for branch
/// * `PRResult::Error(message)` - PR creation failed
pub fn create_pull_request(spec: &Spec, commits_were_made: bool) -> Result<PRResult> {
    // Check: commits_were_made
    if !commits_were_made {
        return Ok(PRResult::Skipped(
            "No commits were made in this session".to_string(),
        ));
    }

    // Check: in git repo
    if !git::is_git_repo() {
        return Ok(PRResult::Skipped("Not in a git repository".to_string()));
    }

    // Check: gh CLI installed
    if !is_gh_installed() {
        return Ok(PRResult::Skipped(
            "GitHub CLI (gh) is not installed".to_string(),
        ));
    }

    // Check: gh authenticated
    if !is_gh_authenticated() {
        return Ok(PRResult::Skipped(
            "Not authenticated with GitHub CLI (run 'gh auth login')".to_string(),
        ));
    }

    // Check: not on main/master branch
    let current_branch = git::current_branch()?;
    if current_branch == "main" || current_branch == "master" {
        return Ok(PRResult::Skipped(format!(
            "Cannot create PR from {} branch",
            current_branch
        )));
    }

    // Push branch to remote before creating PR (or updating existing PR)
    print_pushing_branch(&current_branch);
    match git::push_branch(&current_branch)? {
        PushResult::Success => {
            print_push_success();
        }
        PushResult::AlreadyUpToDate => {
            print_push_already_up_to_date();
        }
        PushResult::Error(msg) => {
            return Ok(PRResult::Error(format!("Failed to push branch: {}", msg)));
        }
    }

    // Check: PR already exists for this branch
    if let Ok(Some(existing_url)) = get_existing_pr_url(&current_branch) {
        return Ok(PRResult::AlreadyExists(existing_url));
    }

    // Create the PR
    let title = format_pr_title(spec);
    let body = format_pr_description(spec);

    let output = Command::new("gh")
        .args(["pr", "create", "--title", &title, "--body", &body])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(PRResult::Error(format!(
            "Failed to create PR: {}",
            stderr.trim()
        )));
    }

    // Extract PR URL from stdout
    let stdout = String::from_utf8_lossy(&output.stdout);
    let pr_url = stdout.trim().to_string();

    if pr_url.is_empty() {
        return Ok(PRResult::Error(
            "PR created but no URL was returned".to_string(),
        ));
    }

    Ok(PRResult::Success(pr_url))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::UserStory;

    #[test]
    fn test_format_pr_description_basic() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "A test feature description.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "First Story".to_string(),
                description: "This is the first story.".to_string(),
                acceptance_criteria: vec!["Criterion 1".to_string()],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Summary"));
        assert!(result.contains("A test feature description."));
        // Incomplete story should appear under "Changes" section
        assert!(result.contains("## Changes"));
        assert!(result.contains("### US-001: First Story"));
        assert!(result.contains("This is the first story."));
    }

    #[test]
    fn test_format_pr_description_multiple_stories_mixed() {
        // Mixed completion status: completed story first, incomplete second
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Multi-story feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Story One".to_string(),
                    description: "First description.".to_string(),
                    acceptance_criteria: vec![],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Story Two".to_string(),
                    description: "Second description.".to_string(),
                    acceptance_criteria: vec![],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Verify both stories are included
        assert!(result.contains("### US-001: Story One"));
        assert!(result.contains("First description."));
        assert!(result.contains("### US-002: Story Two"));
        assert!(result.contains("Second description."));

        // Verify structure order: Summary -> Completed -> Remaining
        let summary_pos = result.find("## Summary").unwrap();
        let completed_pos = result.find("## Completed").unwrap();
        let remaining_pos = result.find("## Remaining").unwrap();
        assert!(summary_pos < completed_pos);
        assert!(completed_pos < remaining_pos);

        // Completed story should be under Completed section
        let story_one_pos = result.find("### US-001").unwrap();
        assert!(story_one_pos > completed_pos && story_one_pos < remaining_pos);

        // Incomplete story should be under Remaining section
        let story_two_pos = result.find("### US-002").unwrap();
        assert!(story_two_pos > remaining_pos);
    }

    #[test]
    fn test_format_pr_description_with_newlines_in_description() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Line one.\nLine two.\nLine three.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test".to_string(),
                description: "Story line one.\nStory line two.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Newlines should be preserved in the output
        assert!(result.contains("Line one.\nLine two.\nLine three."));
        assert!(result.contains("Story line one.\nStory line two."));
    }

    #[test]
    fn test_format_pr_description_output_is_clean() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Clean output test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Clean".to_string(),
                description: "Clean story.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should not have excessive trailing whitespace
        assert!(!result.ends_with("\n\n"));
        // Should start with ## Summary
        assert!(result.starts_with("## Summary"));
    }

    // ========================================================================
    // US-001: Acceptance criteria as checkboxes tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_acceptance_criteria_unchecked() {
        // Incomplete story (passes: false) should show unchecked boxes
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test Story".to_string(),
                description: "A test story.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [ ] First criterion"));
        assert!(result.contains("- [ ] Second criterion"));
        // Should NOT contain checked boxes
        assert!(!result.contains("- [x]"));
    }

    #[test]
    fn test_format_pr_description_acceptance_criteria_checked() {
        // Completed story (passes: true) should show checked boxes
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Completed Story".to_string(),
                description: "A completed story.".to_string(),
                acceptance_criteria: vec![
                    "Done criterion".to_string(),
                    "Also done criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [x] Done criterion"));
        assert!(result.contains("- [x] Also done criterion"));
        // Should NOT contain unchecked boxes
        assert!(!result.contains("- [ ]"));
    }

    #[test]
    fn test_format_pr_description_empty_acceptance_criteria_skipped() {
        // Story with empty acceptance_criteria should not show the section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story Without Criteria".to_string(),
                description: "No acceptance criteria here.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain acceptance criteria section
        assert!(!result.contains("**Acceptance Criteria:**"));
        assert!(!result.contains("- [ ]"));
        assert!(!result.contains("- [x]"));
        // Story content should still be present
        assert!(result.contains("### US-001: Story Without Criteria"));
        assert!(result.contains("No acceptance criteria here."));
    }

    #[test]
    fn test_format_pr_description_mixed_story_statuses() {
        // Multiple stories with different passes status
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Mixed status feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Complete Story".to_string(),
                    description: "This one is done.".to_string(),
                    acceptance_criteria: vec!["Completed criterion".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Incomplete Story".to_string(),
                    description: "This one is not done.".to_string(),
                    acceptance_criteria: vec!["Pending criterion".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // First story should have checked boxes
        assert!(result.contains("- [x] Completed criterion"));
        // Second story should have unchecked boxes
        assert!(result.contains("- [ ] Pending criterion"));
    }

    #[test]
    fn test_format_pr_description_acceptance_criteria_order_preserved() {
        // Criteria should appear in the same order as in the spec
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Ordered Story".to_string(),
                description: "Check order.".to_string(),
                acceptance_criteria: vec![
                    "First".to_string(),
                    "Second".to_string(),
                    "Third".to_string(),
                ],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Verify order by checking positions
        let first_pos = result.find("- [ ] First").unwrap();
        let second_pos = result.find("- [ ] Second").unwrap();
        let third_pos = result.find("- [ ] Third").unwrap();
        assert!(first_pos < second_pos);
        assert!(second_pos < third_pos);
    }

    // ========================================================================
    // US-002: Separate completed and incomplete stories tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_all_stories_complete() {
        // When all stories are complete, show "Completed" section only (no "Remaining")
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "All complete feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "First Complete".to_string(),
                    description: "First done.".to_string(),
                    acceptance_criteria: vec!["Criterion A".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Second Complete".to_string(),
                    description: "Second done.".to_string(),
                    acceptance_criteria: vec!["Criterion B".to_string()],
                    priority: 2,
                    passes: true,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have "Completed" section
        assert!(result.contains("## Completed"));
        // Should NOT have "Remaining" or "Changes" sections
        assert!(!result.contains("## Remaining"));
        assert!(!result.contains("## Changes"));
        // Both stories should be present under Completed
        assert!(result.contains("### US-001: First Complete"));
        assert!(result.contains("### US-002: Second Complete"));
        // All checkboxes should be checked
        assert!(result.contains("- [x] Criterion A"));
        assert!(result.contains("- [x] Criterion B"));
    }

    #[test]
    fn test_format_pr_description_no_stories_complete() {
        // When no stories are complete, show all under "Changes" (not "Completed" or "Remaining")
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Nothing complete yet.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "First Incomplete".to_string(),
                    description: "Not done yet.".to_string(),
                    acceptance_criteria: vec!["Pending A".to_string()],
                    priority: 1,
                    passes: false,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Second Incomplete".to_string(),
                    description: "Also not done.".to_string(),
                    acceptance_criteria: vec!["Pending B".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have "Changes" section
        assert!(result.contains("## Changes"));
        // Should NOT have "Completed" or "Remaining" sections
        assert!(!result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        // Both stories should be present under Changes
        assert!(result.contains("### US-001: First Incomplete"));
        assert!(result.contains("### US-002: Second Incomplete"));
        // All checkboxes should be unchecked
        assert!(result.contains("- [ ] Pending A"));
        assert!(result.contains("- [ ] Pending B"));
    }

    #[test]
    fn test_format_pr_description_mixed_completion_status() {
        // Mixed: some complete, some incomplete - show both sections
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Partially complete feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Done Story".to_string(),
                    description: "This is done.".to_string(),
                    acceptance_criteria: vec!["Done criterion".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Pending Story".to_string(),
                    description: "Not done yet.".to_string(),
                    acceptance_criteria: vec!["Pending criterion".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have both "Completed" and "Remaining" sections
        assert!(result.contains("## Completed"));
        assert!(result.contains("## Remaining"));
        // Should NOT have "Changes" section
        assert!(!result.contains("## Changes"));

        // Verify correct section ordering
        let completed_pos = result.find("## Completed").unwrap();
        let remaining_pos = result.find("## Remaining").unwrap();
        assert!(completed_pos < remaining_pos);

        // Completed story in Completed section
        let done_story_pos = result.find("### US-001: Done Story").unwrap();
        assert!(done_story_pos > completed_pos && done_story_pos < remaining_pos);

        // Incomplete story in Remaining section
        let pending_story_pos = result.find("### US-002: Pending Story").unwrap();
        assert!(pending_story_pos > remaining_pos);

        // Checkboxes match completion status
        assert!(result.contains("- [x] Done criterion"));
        assert!(result.contains("- [ ] Pending criterion"));
    }

    #[test]
    fn test_format_pr_description_story_content_in_sections() {
        // Verify each story shows ID, title, description, and acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Content verification test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-042".to_string(),
                title: "Detailed Story".to_string(),
                description: "A story with full details.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Story header: ### US-042: Detailed Story
        assert!(result.contains("### US-042: Detailed Story"));
        // Description
        assert!(result.contains("A story with full details."));
        // Acceptance criteria header and items
        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [x] First criterion"));
        assert!(result.contains("- [x] Second criterion"));
    }

    #[test]
    fn test_format_pr_description_single_complete_story() {
        // Single complete story should show "Completed" section, no "Remaining"
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Single story feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Only Story".to_string(),
                description: "The one and only.".to_string(),
                acceptance_criteria: vec!["It works".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        assert!(!result.contains("## Changes"));
        assert!(result.contains("### US-001: Only Story"));
    }

    #[test]
    fn test_format_pr_description_single_incomplete_story() {
        // Single incomplete story should show "Changes" section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Single incomplete feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Incomplete Story".to_string(),
                description: "Still working on it.".to_string(),
                acceptance_criteria: vec!["To be done".to_string()],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Changes"));
        assert!(!result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        assert!(result.contains("### US-001: Incomplete Story"));
    }

    #[test]
    fn test_is_gh_installed_returns_bool() {
        // This test just verifies the function runs without panicking
        // and returns a boolean (actual result depends on system)
        let result = is_gh_installed();
        assert!(result || !result); // Always true, just confirms it returns bool
    }

    #[test]
    fn test_is_gh_authenticated_returns_bool() {
        // This test verifies the function runs without panicking
        let result = is_gh_authenticated();
        assert!(result || !result);
    }

    #[test]
    fn test_pr_exists_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = pr_exists_for_branch("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
    }

    #[test]
    fn test_get_existing_pr_url_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = get_existing_pr_url("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
        // Should return None since no PR exists
        if let Ok(url) = result {
            assert!(url.is_none());
        }
    }

    #[test]
    fn test_pr_exists_handles_empty_json_array() {
        // Verify our parsing logic handles empty arrays correctly
        let empty_json = "[]";
        let trimmed = empty_json.trim();
        assert_eq!(trimmed, "[]");
        assert!(trimmed == "[]" || trimmed.is_empty());
    }

    #[test]
    fn test_get_existing_pr_url_parses_json_correctly() {
        // Test the JSON parsing logic
        let json_str = r#"[{"url":"https://github.com/owner/repo/pull/123"}]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();
        assert!(!parsed.is_empty());
        let url = parsed[0].get("url").and_then(|v| v.as_str());
        assert_eq!(url, Some("https://github.com/owner/repo/pull/123"));
    }

    #[test]
    fn test_pr_result_success_contains_url() {
        let url = "https://github.com/owner/repo/pull/42".to_string();
        let result = PRResult::Success(url.clone());
        assert_eq!(result, PRResult::Success(url));
    }

    #[test]
    fn test_pr_result_skipped_contains_reason() {
        let reason = "gh CLI not installed".to_string();
        let result = PRResult::Skipped(reason.clone());
        assert_eq!(result, PRResult::Skipped(reason));
    }

    #[test]
    fn test_pr_result_already_exists_contains_url() {
        let url = "https://github.com/owner/repo/pull/99".to_string();
        let result = PRResult::AlreadyExists(url.clone());
        assert_eq!(result, PRResult::AlreadyExists(url));
    }

    #[test]
    fn test_pr_result_error_contains_message() {
        let message = "Failed to create PR: permission denied".to_string();
        let result = PRResult::Error(message.clone());
        assert_eq!(result, PRResult::Error(message));
    }

    #[test]
    fn test_pr_result_variants_are_distinct() {
        let url = "https://github.com/owner/repo/pull/1".to_string();
        let success = PRResult::Success(url.clone());
        let skipped = PRResult::Skipped(url.clone());
        let already_exists = PRResult::AlreadyExists(url.clone());
        let updated = PRResult::Updated(url.clone());
        let error = PRResult::Error(url.clone());

        // Each variant should be distinct even with the same inner value
        assert_ne!(success, skipped);
        assert_ne!(success, already_exists);
        assert_ne!(success, updated);
        assert_ne!(success, error);
        assert_ne!(skipped, already_exists);
        assert_ne!(skipped, updated);
        assert_ne!(skipped, error);
        assert_ne!(already_exists, updated);
        assert_ne!(already_exists, error);
        assert_ne!(updated, error);
    }

    #[test]
    fn test_pr_result_clone() {
        let original = PRResult::Success("https://github.com/owner/repo/pull/5".to_string());
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_create_pull_request_skips_when_no_commits() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());

        match result.unwrap() {
            PRResult::Skipped(reason) => {
                assert!(reason.contains("No commits"));
            }
            _ => panic!("Expected PRResult::Skipped"),
        }
    }

    #[test]
    fn test_create_pull_request_returns_result() {
        // This test verifies the function runs without panicking
        // and returns a valid Result (actual outcome depends on environment)
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, true);
        assert!(result.is_ok());

        // The result should be one of the valid PRResult variants
        let pr_result = result.unwrap();
        match pr_result {
            PRResult::Success(_)
            | PRResult::Skipped(_)
            | PRResult::AlreadyExists(_)
            | PRResult::Updated(_)
            | PRResult::Error(_) => {}
        }
    }

    #[test]
    fn test_create_pull_request_checks_prerequisites_in_order() {
        // Test that commits_were_made is checked first
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // When commits_were_made is false, should skip immediately
        // regardless of other conditions
        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());

        if let Ok(PRResult::Skipped(reason)) = result {
            assert!(
                reason.contains("No commits"),
                "Should skip due to no commits first"
            );
        } else {
            panic!("Expected Skipped result for no commits");
        }
    }

    #[test]
    fn test_create_pull_request_with_commits_checks_git_repo() {
        // When commits_were_made is true, the function should proceed
        // to check git repo status (we're in a git repo, so it passes)
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, true);
        assert!(result.is_ok());

        // Should not return "No commits" skip since commits_were_made is true
        if let Ok(PRResult::Skipped(reason)) = &result {
            assert!(
                !reason.contains("No commits"),
                "Should not skip due to commits when commits_were_made is true"
            );
        }
    }

    #[test]
    fn test_create_pull_request_function_signature() {
        // Verify the function signature matches the acceptance criteria
        fn _check_signature(_spec: &Spec, _commits: bool) -> Result<PRResult> {
            create_pull_request(_spec, _commits)
        }

        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // This test just verifies compilation with the correct signature
        let _ = _check_signature(&spec, false);
    }

    #[test]
    fn test_create_pull_request_uses_spec_description_as_title() {
        // The function uses spec.description as the PR title
        // We can't easily test the actual gh command, but we verify
        // the function has access to the spec and doesn't panic
        let spec = Spec {
            project: "my-project".to_string(),
            branch_name: "feature/awesome".to_string(),
            description: "Add awesome feature with multiple components".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Awesome Story".to_string(),
                description: "Make it awesome".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        // Just verify the function accepts the spec correctly
        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());
    }

    // ========================================================================
    // US-000: Push before PR creation tests
    // ========================================================================

    #[test]
    fn test_create_pull_request_order_of_operations() {
        // This test documents the expected order of operations in create_pull_request:
        // 1. Check commits_were_made
        // 2. Check git repo
        // 3. Check gh installed
        // 4. Check gh authenticated
        // 5. Check not on main/master
        // 6. Check PR doesn't already exist
        // 7. Push branch to remote <-- NEW STEP
        // 8. Create PR
        //
        // The push step (7) must happen BEFORE the gh pr create call (8).
        // This is verified by the code structure and this documentation test.

        // When commits_were_made is false, we never reach the push step
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());
        // Should skip due to no commits, never reaching push or PR creation
        if let Ok(PRResult::Skipped(reason)) = result {
            assert!(reason.contains("No commits"));
        }
    }

    #[test]
    fn test_push_result_error_propagates_as_pr_error() {
        // When push fails, create_pull_request should return PRResult::Error
        // This test documents the expected behavior - actual testing would require
        // mocking git operations which is not easily done in unit tests.

        // The implementation handles push failure by returning:
        // PRResult::Error(format!("Failed to push branch: {}", msg))
        //
        // This is the expected behavior based on acceptance criteria:
        // "If push fails, transition to Failed state with a clear error message"

        use crate::git::PushResult;

        let error_msg = "remote rejected";
        let push_error = PushResult::Error(error_msg.to_string());
        assert!(matches!(push_error, PushResult::Error(_)));
    }

    // ========================================================================
    // US-003: Implementation notes in PR description tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_notes_included_when_present() {
        // Story with non-empty notes should show the notes section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story With Notes".to_string(),
                description: "A story that has implementation notes.".to_string(),
                acceptance_criteria: vec!["Some criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "This is an important implementation note for reviewers.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Notes:**"));
        assert!(result.contains("This is an important implementation note for reviewers."));
    }

    #[test]
    fn test_format_pr_description_notes_excluded_when_empty() {
        // Story with empty notes should NOT show the notes section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story Without Notes".to_string(),
                description: "A story with no notes.".to_string(),
                acceptance_criteria: vec!["Some criterion".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain notes section
        assert!(!result.contains("**Notes:**"));
        // Story content should still be present
        assert!(result.contains("### US-001: Story Without Notes"));
        assert!(result.contains("A story with no notes."));
    }

    #[test]
    fn test_format_pr_description_notes_appear_after_acceptance_criteria() {
        // Notes should appear after acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Ordered Story".to_string(),
                description: "Check ordering.".to_string(),
                acceptance_criteria: vec!["First criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "Implementation context here.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Verify ordering: Acceptance Criteria before Notes
        let criteria_pos = result.find("**Acceptance Criteria:**").unwrap();
        let notes_pos = result.find("**Notes:**").unwrap();
        assert!(
            criteria_pos < notes_pos,
            "Acceptance Criteria should appear before Notes"
        );
    }

    #[test]
    fn test_format_pr_description_notes_with_no_acceptance_criteria() {
        // Notes should still appear even if there are no acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Notes Only Story".to_string(),
                description: "Story with notes but no criteria.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: true,
                notes: "These notes stand alone.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain acceptance criteria section
        assert!(!result.contains("**Acceptance Criteria:**"));
        // Should contain notes section
        assert!(result.contains("**Notes:**"));
        assert!(result.contains("These notes stand alone."));
    }

    #[test]
    fn test_format_pr_description_notes_multiline() {
        // Multi-line notes should be preserved
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Multiline Notes".to_string(),
                description: "Story with detailed notes.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: true,
                notes: "Line one of notes.\nLine two of notes.\nLine three.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("Line one of notes.\nLine two of notes.\nLine three."));
    }

    #[test]
    fn test_format_pr_description_mixed_stories_with_and_without_notes() {
        // Multiple stories: some with notes, some without
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Mixed notes feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Story With Notes".to_string(),
                    description: "Has notes.".to_string(),
                    acceptance_criteria: vec!["Criterion A".to_string()],
                    priority: 1,
                    passes: true,
                    notes: "Important context for US-001.".to_string(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Story Without Notes".to_string(),
                    description: "No notes here.".to_string(),
                    acceptance_criteria: vec!["Criterion B".to_string()],
                    priority: 2,
                    passes: true,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // First story should have notes
        assert!(result.contains("Important context for US-001."));
        // Should have exactly one **Notes:** section (for US-001 only)
        assert_eq!(result.matches("**Notes:**").count(), 1);
    }

    #[test]
    fn test_format_pr_description_no_double_blank_lines_with_notes() {
        // Verify clean formatting without excessive whitespace
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Clean formatting test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Clean Story".to_string(),
                description: "Clean description.".to_string(),
                acceptance_criteria: vec!["Clean criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "Clean notes.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should not have triple newlines (which would indicate double blank lines)
        assert!(
            !result.contains("\n\n\n"),
            "Should not have double blank lines"
        );
    }

    // ========================================================================
    // US-004: Update existing PR description tests
    // ========================================================================

    #[test]
    fn test_pr_result_updated_contains_url() {
        let url = "https://github.com/owner/repo/pull/42".to_string();
        let result = PRResult::Updated(url.clone());
        assert_eq!(result, PRResult::Updated(url));
    }

    #[test]
    fn test_pr_result_updated_clone() {
        let original = PRResult::Updated("https://github.com/owner/repo/pull/5".to_string());
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_get_existing_pr_number_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = get_existing_pr_number("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
        // Should return None since no PR exists
        if let Ok(number) = result {
            assert!(number.is_none());
        }
    }

    #[test]
    fn test_get_existing_pr_number_parses_json_correctly() {
        // Test the JSON parsing logic
        let json_str = r#"[{"number":123}]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();
        assert!(!parsed.is_empty());
        let number = parsed[0].get("number").and_then(|v| v.as_u64());
        assert_eq!(number, Some(123));
    }

    #[test]
    fn test_get_existing_pr_number_handles_empty_json_array() {
        // Verify our parsing logic handles empty arrays correctly
        let empty_json = "[]";
        let trimmed = empty_json.trim();
        assert_eq!(trimmed, "[]");
        assert!(trimmed == "[]" || trimmed.is_empty());
    }

    #[test]
    fn test_update_pr_description_function_signature() {
        // Verify the function signature matches the acceptance criteria
        fn _check_signature(_spec: &Spec, _pr_number: u32) -> Result<PRResult> {
            update_pr_description(_spec, _pr_number)
        }

        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // This test just verifies compilation with the correct signature
        let _ = _check_signature(&spec, 123);
    }

    #[test]
    fn test_update_pr_description_returns_result() {
        // This test verifies the function runs without panicking
        // and returns a valid Result (actual outcome depends on environment)
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test Story".to_string(),
                description: "A test.".to_string(),
                acceptance_criteria: vec!["Criterion".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = update_pr_description(&spec, 99999);
        assert!(result.is_ok());

        // The result should be either Updated or Error (depending on gh availability)
        let pr_result = result.unwrap();
        match pr_result {
            PRResult::Updated(_) | PRResult::Error(_) => {}
            _ => panic!("Expected Updated or Error variant"),
        }
    }

    #[test]
    fn test_update_pr_description_uses_format_pr_description() {
        // Verify that update_pr_description uses the same formatting as create_pull_request
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature for update.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Updated Story".to_string(),
                description: "This story was updated.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: "Important notes for reviewers.".to_string(),
            }],
        };

        // Generate the expected body
        let expected_body = format_pr_description(&spec);

        // Verify the expected body contains all the expected elements
        assert!(expected_body.contains("## Summary"));
        assert!(expected_body.contains("Test feature for update."));
        assert!(expected_body.contains("### US-001: Updated Story"));
        assert!(expected_body.contains("- [x] First criterion"));
        assert!(expected_body.contains("- [x] Second criterion"));
        assert!(expected_body.contains("**Notes:**"));
        assert!(expected_body.contains("Important notes for reviewers."));
    }

    // ========================================================================
    // US-005: PR title formatting tests
    // ========================================================================

    #[test]
    fn test_format_pr_title_basic() {
        // Simple single-line description
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Add user authentication".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Add user authentication");
    }

    #[test]
    fn test_format_pr_title_with_project_prefix() {
        // Project field should prefix the title
        let spec = Spec {
            project: "autom8".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Add user authentication".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "[autom8] Add user authentication");
    }

    #[test]
    fn test_format_pr_title_multiline_uses_first_line() {
        // Multi-line description should use only the first line
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description:
                "Improve PR descriptions\nThis is a longer explanation.\nAnd more details."
                    .to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Improve PR descriptions");
    }

    #[test]
    fn test_format_pr_title_single_line_uses_first_sentence() {
        // Single-line description with multiple sentences should use first sentence
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Add feature X. This feature does something important. It helps users."
                .to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Add feature X.");
    }

    #[test]
    fn test_format_pr_title_truncation_at_72_chars() {
        // Title longer than 72 characters should be truncated with "..."
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that definitely exceeds the seventy-two character limit for PR titles".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_truncation_at_word_boundary() {
        // Truncation should try to happen at word boundaries
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that definitely exceeds the seventy-two character limit".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.ends_with("..."));
        // Should not cut in the middle of a word
        assert!(!title.ends_with("seven..."));
    }

    #[test]
    fn test_format_pr_title_with_project_truncation() {
        // Project prefix + long title should still truncate to 72 chars total
        let spec = Spec {
            project: "myproject".to_string(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that will exceed the limit when combined with the project prefix".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.starts_with("[myproject]"));
        assert!(title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_exactly_72_chars_no_truncation() {
        // Title that is exactly 72 characters should not be truncated
        let desc = "A".repeat(72);
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: desc.clone(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title.len(), 72);
        assert!(!title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_empty_project_no_prefix() {
        // Empty project field should not add prefix
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Simple title".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(!title.starts_with("["));
        assert_eq!(title, "Simple title");
    }

    #[test]
    fn test_extract_first_line_or_sentence_multiline() {
        let text = "First line here\nSecond line\nThird line";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "First line here");
    }

    #[test]
    fn test_extract_first_line_or_sentence_single_sentence() {
        let text = "This is a sentence. This is another. And one more.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "This is a sentence.");
    }

    #[test]
    fn test_extract_first_line_or_sentence_no_boundaries() {
        let text = "Just some text without periods or newlines";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "Just some text without periods or newlines");
    }

    #[test]
    fn test_extract_first_line_or_sentence_exclamation() {
        let text = "Important announcement! More details here.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "Important announcement!");
    }

    #[test]
    fn test_extract_first_line_or_sentence_question() {
        let text = "What is this? It's a test.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "What is this?");
    }

    #[test]
    fn test_truncate_with_ellipsis_short_text() {
        let text = "Short text";
        let result = truncate_with_ellipsis(text, 72);
        assert_eq!(result, "Short text");
    }

    #[test]
    fn test_truncate_with_ellipsis_long_text() {
        let text = "This is a very long text that needs to be truncated because it exceeds the maximum allowed length";
        let result = truncate_with_ellipsis(text, 50);
        assert!(result.len() <= 50);
        assert!(result.ends_with("..."));
    }

    #[test]
    fn test_truncate_with_ellipsis_word_boundary() {
        let text = "Hello world this is a test";
        let result = truncate_with_ellipsis(text, 20);
        // Should truncate at word boundary
        assert_eq!(result, "Hello world this...");
    }

    #[test]
    fn test_format_pr_title_full_description_in_body() {
        // Verify that the full description is preserved in the body
        let long_desc = "First line of description.\nSecond line with more details.\nThird line with even more context.";
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "feature/test".to_string(),
            description: long_desc.to_string(),
            user_stories: vec![],
        };

        // Title should be just the first line
        let title = format_pr_title(&spec);
        assert_eq!(title, "[test] First line of description.");

        // Body should contain the full description
        let body = format_pr_description(&spec);
        assert!(body.contains(long_desc));
    }
}
