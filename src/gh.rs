//! GitHub CLI (gh) integration for PR operations
//!
//! This module provides functions to interact with the GitHub CLI for
//! checking prerequisites and managing pull requests.

use crate::error::{Autom8Error, Result};
use crate::git::{self, PushResult};
use crate::output::{print_push_already_up_to_date, print_push_success, print_pushing_branch};
use crate::spec::Spec;
use std::process::Command;

/// Information about an open pull request
#[derive(Debug, Clone, PartialEq)]
pub struct PullRequestInfo {
    /// PR number
    pub number: u32,
    /// PR title
    pub title: String,
    /// Head branch name (the source branch)
    pub head_branch: String,
    /// PR URL
    pub url: String,
}

/// Result of attempting to detect a PR for the current branch
#[derive(Debug, Clone, PartialEq)]
pub enum PRDetectionResult {
    /// Found a PR for the current branch
    Found(PullRequestInfo),
    /// Current branch is main/master with no PR
    OnMainBranch,
    /// On a feature branch but no open PR exists for it
    NoPRForBranch(String),
    /// Error occurred during detection
    Error(String),
}

/// Result type for PR creation operations
///
/// Captures all possible outcomes of the PR creation step.
/// Note that `Skipped` represents a successful state transition (not a failure)
/// when prerequisites aren't met.
#[derive(Debug, Clone, PartialEq)]
pub enum PRResult {
    /// PR created successfully, contains PR URL
    Success(String),
    /// Prerequisites not met, contains reason for skip
    Skipped(String),
    /// PR already exists for branch, contains existing PR URL
    AlreadyExists(String),
    /// PR description updated successfully, contains PR URL
    Updated(String),
    /// PR creation attempted but failed, contains error message
    Error(String),
}

/// Maximum length for PR titles (GitHub standard)
const PR_TITLE_MAX_LENGTH: usize = 72;

/// Format a Spec into a concise PR title
///
/// The title is generated by:
/// 1. Taking the first line or sentence of the description
/// 2. Truncating to 72 characters (GitHub standard) with "..." if longer
/// 3. Optionally prefixing with `[project]` if the spec has a project field
///
/// The full description remains in the PR body summary section.
pub fn format_pr_title(spec: &Spec) -> String {
    // Extract the first line or first sentence from the description
    let first_part = extract_first_line_or_sentence(&spec.description);

    // Build title with optional project prefix
    let title = if spec.project.is_empty() {
        first_part
    } else {
        format!("[{}] {}", spec.project, first_part)
    };

    // Truncate to max length with ellipsis if needed
    truncate_with_ellipsis(&title, PR_TITLE_MAX_LENGTH)
}

/// Extract the first line or first sentence from text
///
/// Returns the first line if the text is multi-line, or the first sentence
/// (ending in '.', '!', or '?') if single-line. Falls back to the whole text
/// if no sentence boundary is found.
fn extract_first_line_or_sentence(text: &str) -> String {
    // First, try to get the first line if multi-line
    if let Some(newline_pos) = text.find('\n') {
        let first_line = text[..newline_pos].trim();
        if !first_line.is_empty() {
            return first_line.to_string();
        }
    }

    // For single-line text, try to extract the first sentence
    // Look for sentence-ending punctuation followed by space or end of string
    for (i, c) in text.char_indices() {
        if c == '.' || c == '!' || c == '?' {
            // Check if this is followed by a space or end of string
            let next_idx = i + c.len_utf8();
            if next_idx >= text.len() || text[next_idx..].starts_with(' ') {
                let sentence = text[..=i].trim();
                if !sentence.is_empty() {
                    return sentence.to_string();
                }
            }
        }
    }

    // Fallback: return the whole text trimmed
    text.trim().to_string()
}

/// Truncate a string to a maximum length, adding "..." if truncated
///
/// Truncates at word boundaries when possible to avoid cutting words.
fn truncate_with_ellipsis(text: &str, max_len: usize) -> String {
    if text.len() <= max_len {
        return text.to_string();
    }

    // Reserve space for "..."
    let target_len = max_len - 3;

    // Try to find a word boundary (space) to truncate at
    let truncate_at = text[..target_len].rfind(' ').unwrap_or(target_len);

    format!("{}...", text[..truncate_at].trim_end())
}

/// Format a Spec into a well-structured GitHub PR description in Markdown format
///
/// The output includes:
/// - A Summary section with the spec description
/// - Stories separated by completion status:
///   - "## Completed" section for stories with `passes: true`
///   - "## Remaining" section for stories with `passes: false` (only if completed stories exist)
///   - "## Changes" section if no stories are complete (shows all stories)
///
/// Acceptance criteria are rendered as GitHub-flavored markdown checkboxes:
/// - Completed stories (`passes: true`) show checked boxes: `- [x] Criterion`
/// - Incomplete stories show unchecked boxes: `- [ ] Criterion`
pub fn format_pr_description(spec: &Spec) -> String {
    let mut output = String::new();

    // Summary section
    output.push_str("## Summary\n\n");
    output.push_str(&spec.description);
    output.push_str("\n\n");

    // Partition stories by completion status
    let completed: Vec<_> = spec.user_stories.iter().filter(|s| s.passes).collect();
    let incomplete: Vec<_> = spec.user_stories.iter().filter(|s| !s.passes).collect();

    if completed.is_empty() {
        // No completed stories: show all under "Changes"
        output.push_str("## Changes\n\n");
        for story in &spec.user_stories {
            format_story(&mut output, story);
        }
    } else {
        // Has completed stories: show "Completed" section
        output.push_str("## Completed\n\n");
        for story in &completed {
            format_story(&mut output, story);
        }

        // Only show "Remaining" if there are incomplete stories
        if !incomplete.is_empty() {
            output.push_str("## Remaining\n\n");
            for story in &incomplete {
                format_story(&mut output, story);
            }
        }
    }

    // Trim trailing whitespace but keep one trailing newline
    output.trim_end().to_string()
}

/// Format a single user story for the PR description
fn format_story(output: &mut String, story: &crate::spec::UserStory) {
    // Format: ### US-001: [title]
    output.push_str(&format!("### {}: {}\n\n", story.id, story.title));
    output.push_str(&story.description);
    output.push_str("\n\n");

    // Add acceptance criteria as checkboxes if present
    if !story.acceptance_criteria.is_empty() {
        output.push_str("**Acceptance Criteria:**\n\n");
        let checkbox = if story.passes { "[x]" } else { "[ ]" };
        for criterion in &story.acceptance_criteria {
            output.push_str(&format!("- {} {}\n", checkbox, criterion));
        }
        output.push('\n');
    }

    // Add notes if present
    if !story.notes.is_empty() {
        output.push_str("**Notes:**\n\n");
        output.push_str(&story.notes);
        output.push_str("\n\n");
    }
}

/// Check if the GitHub CLI (gh) is installed and available in PATH
pub fn is_gh_installed() -> bool {
    Command::new("gh")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Check if the user is authenticated with GitHub CLI
///
/// Uses `gh auth status` which returns exit code 0 if authenticated.
pub fn is_gh_authenticated() -> bool {
    Command::new("gh")
        .args(["auth", "status"])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Check if a pull request already exists for the given branch
///
/// Returns `Ok(true)` if a PR exists, `Ok(false)` if no PR exists,
/// or an error if the command fails.
pub fn pr_exists_for_branch(branch: &str) -> Result<bool> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "number"])
        .output()?;

    if !output.status.success() {
        // On error, return false (non-blocking behavior)
        return Ok(false);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array [] means no PRs exist
    // Non-empty array means at least one PR exists
    Ok(trimmed != "[]" && !trimmed.is_empty())
}

/// Get the URL of an existing pull request for the given branch
///
/// Returns `Ok(Some(url))` if a PR exists, `Ok(None)` if no PR exists,
/// or an error if the command fails.
pub fn get_existing_pr_url(branch: &str) -> Result<Option<String>> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "url"])
        .output()?;

    if !output.status.success() {
        // On error, return None (non-blocking behavior)
        return Ok(None);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(None);
    }

    // Parse JSON array to extract URL
    // Expected format: [{"url":"https://github.com/..."}]
    let parsed: std::result::Result<Vec<serde_json::Value>, _> = serde_json::from_str(trimmed);

    match parsed {
        Ok(prs) if !prs.is_empty() => {
            if let Some(url) = prs[0].get("url").and_then(|v| v.as_str()) {
                Ok(Some(url.to_string()))
            } else {
                Ok(None)
            }
        }
        _ => Ok(None),
    }
}

/// Get the PR number for an existing pull request for the given branch
///
/// Returns `Ok(Some(number))` if a PR exists, `Ok(None)` if no PR exists,
/// or an error if the command fails.
pub fn get_existing_pr_number(branch: &str) -> Result<Option<u32>> {
    let output = Command::new("gh")
        .args(["pr", "list", "--head", branch, "--json", "number"])
        .output()?;

    if !output.status.success() {
        // On error, return None (non-blocking behavior)
        return Ok(None);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(None);
    }

    // Parse JSON array to extract number
    // Expected format: [{"number":123}]
    let parsed: std::result::Result<Vec<serde_json::Value>, _> = serde_json::from_str(trimmed);

    match parsed {
        Ok(prs) if !prs.is_empty() => {
            if let Some(number) = prs[0].get("number").and_then(|v| v.as_u64()) {
                Ok(Some(number as u32))
            } else {
                Ok(None)
            }
        }
        _ => Ok(None),
    }
}

/// Update the description of an existing pull request
///
/// Uses `gh pr edit <number> --body <new_body>` to update the PR description.
///
/// # Arguments
/// * `spec` - The spec containing PR description data
/// * `pr_number` - The PR number to update
///
/// # Returns
/// * `PRResult::Updated(url)` - PR updated successfully
/// * `PRResult::Error(message)` - PR update failed
pub fn update_pr_description(spec: &Spec, pr_number: u32) -> Result<PRResult> {
    let body = format_pr_description(spec);

    let output = Command::new("gh")
        .args(["pr", "edit", &pr_number.to_string(), "--body", &body])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(PRResult::Error(format!(
            "Failed to update PR: {}",
            stderr.trim()
        )));
    }

    // Get the PR URL for the success message
    let url_output = Command::new("gh")
        .args(["pr", "view", &pr_number.to_string(), "--json", "url"])
        .output()?;

    if url_output.status.success() {
        let stdout = String::from_utf8_lossy(&url_output.stdout);
        if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(stdout.trim()) {
            if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                return Ok(PRResult::Updated(url.to_string()));
            }
        }
    }

    // Fallback: construct URL from PR number (not ideal but functional)
    Ok(PRResult::Updated(format!("PR #{}", pr_number)))
}

/// Create a pull request for the current branch using the GitHub CLI
///
/// This function orchestrates all prerequisite checks and PR creation.
/// It returns `PRResult::Skipped` (not an error) when prerequisites aren't met,
/// allowing the workflow to continue gracefully.
///
/// # Arguments
/// * `spec` - The spec containing PR title and description data
/// * `commits_were_made` - Whether commits were made in the current session
///
/// # Returns
/// * `PRResult::Success(url)` - PR created successfully
/// * `PRResult::Skipped(reason)` - Prerequisites not met
/// * `PRResult::AlreadyExists(url)` - PR already exists for branch
/// * `PRResult::Error(message)` - PR creation failed
pub fn create_pull_request(spec: &Spec, commits_were_made: bool) -> Result<PRResult> {
    // Check: commits_were_made
    if !commits_were_made {
        return Ok(PRResult::Skipped(
            "No commits were made in this session".to_string(),
        ));
    }

    // Check: in git repo
    if !git::is_git_repo() {
        return Ok(PRResult::Skipped("Not in a git repository".to_string()));
    }

    // Check: gh CLI installed
    if !is_gh_installed() {
        return Ok(PRResult::Skipped(
            "GitHub CLI (gh) is not installed".to_string(),
        ));
    }

    // Check: gh authenticated
    if !is_gh_authenticated() {
        return Ok(PRResult::Skipped(
            "Not authenticated with GitHub CLI (run 'gh auth login')".to_string(),
        ));
    }

    // Check: not on main/master branch
    let current_branch = git::current_branch()?;
    if current_branch == "main" || current_branch == "master" {
        return Ok(PRResult::Skipped(format!(
            "Cannot create PR from {} branch",
            current_branch
        )));
    }

    // Push branch to remote before creating PR (or updating existing PR)
    print_pushing_branch(&current_branch);
    match git::push_branch(&current_branch)? {
        PushResult::Success => {
            print_push_success();
        }
        PushResult::AlreadyUpToDate => {
            print_push_already_up_to_date();
        }
        PushResult::Error(msg) => {
            return Ok(PRResult::Error(format!("Failed to push branch: {}", msg)));
        }
    }

    // Check: PR already exists for this branch
    if let Ok(Some(existing_url)) = get_existing_pr_url(&current_branch) {
        return Ok(PRResult::AlreadyExists(existing_url));
    }

    // Create the PR
    let title = format_pr_title(spec);
    let body = format_pr_description(spec);

    let output = Command::new("gh")
        .args(["pr", "create", "--title", &title, "--body", &body])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Ok(PRResult::Error(format!(
            "Failed to create PR: {}",
            stderr.trim()
        )));
    }

    // Extract PR URL from stdout
    let stdout = String::from_utf8_lossy(&output.stdout);
    let pr_url = stdout.trim().to_string();

    if pr_url.is_empty() {
        return Ok(PRResult::Error(
            "PR created but no URL was returned".to_string(),
        ));
    }

    Ok(PRResult::Success(pr_url))
}

// ============================================================================
// PR Detection Functions (US-001: Detect PR from Current Branch)
// ============================================================================

/// Detect the PR associated with the current git branch.
///
/// This function checks if there's an open PR for the current branch.
/// If on main/master, returns `OnMainBranch`.
/// If on a feature branch without a PR, returns `NoPRForBranch`.
///
/// # Returns
/// * `PRDetectionResult::Found(info)` - Found a PR for the current branch
/// * `PRDetectionResult::OnMainBranch` - Current branch is main/master
/// * `PRDetectionResult::NoPRForBranch(branch)` - No PR for this branch
/// * `PRDetectionResult::Error(msg)` - Error occurred
pub fn detect_pr_for_current_branch() -> Result<PRDetectionResult> {
    // Check: gh CLI installed
    if !is_gh_installed() {
        return Ok(PRDetectionResult::Error(
            "GitHub CLI (gh) is not installed. Install it from https://cli.github.com/".to_string(),
        ));
    }

    // Check: gh authenticated
    if !is_gh_authenticated() {
        return Ok(PRDetectionResult::Error(
            "Not authenticated with GitHub CLI. Run 'gh auth login' to authenticate.".to_string(),
        ));
    }

    // Check: in git repo
    if !git::is_git_repo() {
        return Ok(PRDetectionResult::Error(
            "Not in a git repository.".to_string(),
        ));
    }

    // Get current branch
    let current_branch = git::current_branch()?;

    // Check if on main/master
    if current_branch == "main" || current_branch == "master" {
        return Ok(PRDetectionResult::OnMainBranch);
    }

    // Try to get PR info for current branch
    match get_pr_info_for_branch(&current_branch)? {
        Some(info) => Ok(PRDetectionResult::Found(info)),
        None => Ok(PRDetectionResult::NoPRForBranch(current_branch)),
    }
}

/// Get PR information for a specific branch.
///
/// Returns `Ok(Some(info))` if a PR exists, `Ok(None)` if no PR exists,
/// or an error if the command fails.
pub fn get_pr_info_for_branch(branch: &str) -> Result<Option<PullRequestInfo>> {
    let output = Command::new("gh")
        .args([
            "pr",
            "list",
            "--head",
            branch,
            "--json",
            "number,title,headRefName,url",
            "--state",
            "open",
        ])
        .output()?;

    if !output.status.success() {
        // On error, return None (non-blocking behavior)
        return Ok(None);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(None);
    }

    // Parse JSON array
    let parsed: std::result::Result<Vec<serde_json::Value>, _> = serde_json::from_str(trimmed);

    match parsed {
        Ok(prs) if !prs.is_empty() => {
            let pr = &prs[0];
            let number = pr.get("number").and_then(|v| v.as_u64()).unwrap_or(0) as u32;
            let title = pr
                .get("title")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let head_branch = pr
                .get("headRefName")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let url = pr
                .get("url")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();

            Ok(Some(PullRequestInfo {
                number,
                title,
                head_branch,
                url,
            }))
        }
        _ => Ok(None),
    }
}

/// List all open pull requests in the repository.
///
/// Returns a list of PR info objects sorted by PR number (descending, newest first).
///
/// # Returns
/// * `Ok(Vec<PullRequestInfo>)` - List of open PRs (may be empty)
/// * `Err` - If the gh command fails
pub fn list_open_prs() -> Result<Vec<PullRequestInfo>> {
    let output = Command::new("gh")
        .args([
            "pr",
            "list",
            "--json",
            "number,title,headRefName,url",
            "--state",
            "open",
        ])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to list PRs: {}",
            stderr.trim()
        )));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let trimmed = stdout.trim();

    // Empty array means no PRs
    if trimmed == "[]" || trimmed.is_empty() {
        return Ok(vec![]);
    }

    // Parse JSON array
    let parsed: Vec<serde_json::Value> = serde_json::from_str(trimmed)?;

    let prs: Vec<PullRequestInfo> = parsed
        .iter()
        .map(|pr| {
            let number = pr.get("number").and_then(|v| v.as_u64()).unwrap_or(0) as u32;
            let title = pr
                .get("title")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let head_branch = pr
                .get("headRefName")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let url = pr
                .get("url")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();

            PullRequestInfo {
                number,
                title,
                head_branch,
                url,
            }
        })
        .collect();

    Ok(prs)
}

/// Check prerequisites for PR operations (gh installed and authenticated).
///
/// Returns Ok(()) if all checks pass, or an error message if not.
pub fn check_gh_prerequisites() -> std::result::Result<(), String> {
    if !is_gh_installed() {
        return Err(
            "GitHub CLI (gh) is not installed. Install it from https://cli.github.com/".to_string(),
        );
    }

    if !is_gh_authenticated() {
        return Err(
            "Not authenticated with GitHub CLI. Run 'gh auth login' to authenticate.".to_string(),
        );
    }

    Ok(())
}

// ============================================================================
// US-002: PR Context Gathering (Description, Comments, Reviews)
// ============================================================================

/// A comment on a PR (either inline review comment or conversation comment)
#[derive(Debug, Clone, PartialEq)]
pub struct PRComment {
    /// Comment author's GitHub username
    pub author: String,
    /// The comment body/content
    pub body: String,
    /// File path for inline comments (None for conversation comments)
    pub file_path: Option<String>,
    /// Line number for inline comments (None for conversation comments)
    pub line: Option<u32>,
    /// The comment ID (useful for reference)
    pub id: u64,
    /// URL to the comment
    pub url: String,
}

/// Full context for a PR including description and unresolved comments
#[derive(Debug, Clone)]
pub struct PRContext {
    /// PR number
    pub number: u32,
    /// PR title
    pub title: String,
    /// PR body/description (markdown)
    pub body: String,
    /// PR URL
    pub url: String,
    /// All unresolved comments (both inline and conversation)
    pub unresolved_comments: Vec<PRComment>,
}

/// Result of gathering PR context
#[derive(Debug, Clone)]
pub enum PRContextResult {
    /// Successfully gathered PR context
    Success(PRContext),
    /// No unresolved comments found
    NoUnresolvedComments {
        number: u32,
        title: String,
        body: String,
        url: String,
    },
    /// Error occurred during gathering
    Error(String),
}

/// Fetch the PR description/body via `gh pr view`.
///
/// # Arguments
/// * `pr_number` - The PR number to fetch
///
/// # Returns
/// * `Ok((title, body, url))` - PR title, body, and URL
/// * `Err` - If the command fails
pub fn get_pr_description(pr_number: u32) -> Result<(String, String, String)> {
    let output = Command::new("gh")
        .args([
            "pr",
            "view",
            &pr_number.to_string(),
            "--json",
            "title,body,url",
        ])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to fetch PR description: {}",
            stderr.trim()
        )));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value = serde_json::from_str(stdout.trim())?;

    let title = parsed
        .get("title")
        .and_then(|v| v.as_str())
        .unwrap_or("")
        .to_string();
    let body = parsed
        .get("body")
        .and_then(|v| v.as_str())
        .unwrap_or("")
        .to_string();
    let url = parsed
        .get("url")
        .and_then(|v| v.as_str())
        .unwrap_or("")
        .to_string();

    Ok((title, body, url))
}

/// Fetch unresolved review comments via `gh api`.
///
/// Review comments are inline comments on specific lines of code in PR diffs.
/// This function filters to only return comments that are not marked as resolved.
///
/// # Arguments
/// * `pr_number` - The PR number to fetch comments for
///
/// # Returns
/// * `Ok(Vec<PRComment>)` - List of unresolved inline review comments
/// * `Err` - If the command fails
pub fn get_unresolved_review_comments(pr_number: u32) -> Result<Vec<PRComment>> {
    // First, get the repository owner and name
    let repo_output = Command::new("gh")
        .args(["repo", "view", "--json", "owner,name"])
        .output()?;

    if !repo_output.status.success() {
        let stderr = String::from_utf8_lossy(&repo_output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to get repo info: {}",
            stderr.trim()
        )));
    }

    let repo_stdout = String::from_utf8_lossy(&repo_output.stdout);
    let repo_parsed: serde_json::Value = serde_json::from_str(repo_stdout.trim())?;
    let owner = repo_parsed
        .get("owner")
        .and_then(|v| v.get("login"))
        .and_then(|v| v.as_str())
        .unwrap_or("");
    let name = repo_parsed
        .get("name")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    // Fetch review comments via the API
    // Use the pulls/{pr_number}/comments endpoint for inline review comments
    let api_path = format!("repos/{}/{}/pulls/{}/comments", owner, name, pr_number);
    let output = Command::new("gh")
        .args(["api", &api_path, "--paginate"])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to fetch review comments: {}",
            stderr.trim()
        )));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);

    // Handle pagination - gh api --paginate may return multiple JSON arrays concatenated
    let mut all_comments = Vec::new();
    for line in stdout.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }

        // Try to parse as array first
        if let Ok(comments) = serde_json::from_str::<Vec<serde_json::Value>>(trimmed) {
            for comment in comments {
                if let Some(pr_comment) = parse_review_comment(&comment) {
                    all_comments.push(pr_comment);
                }
            }
        }
    }

    // Now we need to filter for unresolved comments
    // Review comments are considered "resolved" when they're part of a resolved review thread
    // We need to check the GraphQL API for thread resolution status
    let unresolved = filter_unresolved_review_comments(owner, name, pr_number, all_comments)?;

    Ok(unresolved)
}

/// Parse a review comment from the GitHub API response
fn parse_review_comment(comment: &serde_json::Value) -> Option<PRComment> {
    let id = comment.get("id")?.as_u64()?;
    let body = comment.get("body")?.as_str()?.to_string();
    let author = comment
        .get("user")
        .and_then(|u| u.get("login"))
        .and_then(|l| l.as_str())
        .unwrap_or("unknown")
        .to_string();
    let file_path = comment
        .get("path")
        .and_then(|p| p.as_str())
        .map(String::from);
    let line = comment
        .get("line")
        .or_else(|| comment.get("original_line"))
        .and_then(|l| l.as_u64())
        .map(|l| l as u32);
    let url = comment
        .get("html_url")
        .and_then(|u| u.as_str())
        .unwrap_or("")
        .to_string();

    Some(PRComment {
        author,
        body,
        file_path,
        line,
        id,
        url,
    })
}

/// Filter review comments to only include those that are unresolved.
///
/// Uses the GraphQL API to check thread resolution status.
fn filter_unresolved_review_comments(
    owner: &str,
    name: &str,
    pr_number: u32,
    comments: Vec<PRComment>,
) -> Result<Vec<PRComment>> {
    if comments.is_empty() {
        return Ok(vec![]);
    }

    // Use GraphQL to get the resolution status of review threads
    let graphql_query = format!(
        r#"query {{
  repository(owner: "{}", name: "{}") {{
    pullRequest(number: {}) {{
      reviewThreads(first: 100) {{
        nodes {{
          isResolved
          comments(first: 1) {{
            nodes {{
              databaseId
            }}
          }}
        }}
      }}
    }}
  }}
}}"#,
        owner, name, pr_number
    );

    let output = Command::new("gh")
        .args(["api", "graphql", "-f", &format!("query={}", graphql_query)])
        .output()?;

    if !output.status.success() {
        // If GraphQL fails, return all comments (conservative approach)
        return Ok(comments);
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value = serde_json::from_str(stdout.trim())?;

    // Build a set of resolved comment IDs
    let mut resolved_ids: std::collections::HashSet<u64> = std::collections::HashSet::new();

    if let Some(threads) = parsed
        .get("data")
        .and_then(|d| d.get("repository"))
        .and_then(|r| r.get("pullRequest"))
        .and_then(|pr| pr.get("reviewThreads"))
        .and_then(|rt| rt.get("nodes"))
        .and_then(|n| n.as_array())
    {
        for thread in threads {
            let is_resolved = thread
                .get("isResolved")
                .and_then(|r| r.as_bool())
                .unwrap_or(false);

            if is_resolved {
                // Get the first comment's database ID (the thread starter)
                if let Some(comment_id) = thread
                    .get("comments")
                    .and_then(|c| c.get("nodes"))
                    .and_then(|n| n.as_array())
                    .and_then(|arr| arr.first())
                    .and_then(|c| c.get("databaseId"))
                    .and_then(|id| id.as_u64())
                {
                    resolved_ids.insert(comment_id);
                }
            }
        }
    }

    // Filter comments to exclude resolved ones
    let unresolved: Vec<PRComment> = comments
        .into_iter()
        .filter(|c| !resolved_ids.contains(&c.id))
        .collect();

    Ok(unresolved)
}

/// Fetch unresolved conversation comments via `gh api`.
///
/// Conversation comments are general comments on the PR (not inline on code).
/// This returns all issue comments, as GitHub doesn't have a "resolved" concept
/// for general PR conversation comments.
///
/// # Arguments
/// * `pr_number` - The PR number to fetch comments for
///
/// # Returns
/// * `Ok(Vec<PRComment>)` - List of conversation comments
/// * `Err` - If the command fails
pub fn get_conversation_comments(pr_number: u32) -> Result<Vec<PRComment>> {
    // Get repository info
    let repo_output = Command::new("gh")
        .args(["repo", "view", "--json", "owner,name"])
        .output()?;

    if !repo_output.status.success() {
        let stderr = String::from_utf8_lossy(&repo_output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to get repo info: {}",
            stderr.trim()
        )));
    }

    let repo_stdout = String::from_utf8_lossy(&repo_output.stdout);
    let repo_parsed: serde_json::Value = serde_json::from_str(repo_stdout.trim())?;
    let owner = repo_parsed
        .get("owner")
        .and_then(|v| v.get("login"))
        .and_then(|v| v.as_str())
        .unwrap_or("");
    let name = repo_parsed
        .get("name")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    // Fetch issue comments (PR conversation comments use the issues API)
    let api_path = format!("repos/{}/{}/issues/{}/comments", owner, name, pr_number);
    let output = Command::new("gh")
        .args(["api", &api_path, "--paginate"])
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(Autom8Error::GitError(format!(
            "Failed to fetch conversation comments: {}",
            stderr.trim()
        )));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);

    // Handle pagination
    let mut all_comments = Vec::new();
    for line in stdout.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }

        if let Ok(comments) = serde_json::from_str::<Vec<serde_json::Value>>(trimmed) {
            for comment in comments {
                if let Some(pr_comment) = parse_conversation_comment(&comment) {
                    all_comments.push(pr_comment);
                }
            }
        }
    }

    Ok(all_comments)
}

/// Parse a conversation comment from the GitHub API response
fn parse_conversation_comment(comment: &serde_json::Value) -> Option<PRComment> {
    let id = comment.get("id")?.as_u64()?;
    let body = comment.get("body")?.as_str()?.to_string();
    let author = comment
        .get("user")
        .and_then(|u| u.get("login"))
        .and_then(|l| l.as_str())
        .unwrap_or("unknown")
        .to_string();
    let url = comment
        .get("html_url")
        .and_then(|u| u.as_str())
        .unwrap_or("")
        .to_string();

    // Conversation comments don't have file/line context
    Some(PRComment {
        author,
        body,
        file_path: None,
        line: None,
        id,
        url,
    })
}

/// Gather all PR context: description and unresolved comments.
///
/// This function fetches the PR description, unresolved review comments,
/// and conversation comments, combining them into a unified context.
///
/// # Arguments
/// * `pr_number` - The PR number to gather context for
///
/// # Returns
/// * `PRContextResult::Success(context)` - Full PR context with comments
/// * `PRContextResult::NoUnresolvedComments` - PR has no unresolved comments
/// * `PRContextResult::Error(msg)` - Error occurred during gathering
pub fn gather_pr_context(pr_number: u32) -> PRContextResult {
    // Fetch PR description
    let (title, body, url) = match get_pr_description(pr_number) {
        Ok(result) => result,
        Err(e) => return PRContextResult::Error(format!("Failed to get PR description: {}", e)),
    };

    // Fetch unresolved review comments
    let review_comments = match get_unresolved_review_comments(pr_number) {
        Ok(comments) => comments,
        Err(e) => return PRContextResult::Error(format!("Failed to get review comments: {}", e)),
    };

    // Fetch conversation comments
    let conversation_comments = match get_conversation_comments(pr_number) {
        Ok(comments) => comments,
        Err(e) => {
            return PRContextResult::Error(format!("Failed to get conversation comments: {}", e))
        }
    };

    // Combine inline and conversation comments into unified list
    let mut unresolved_comments = Vec::new();
    unresolved_comments.extend(review_comments);
    unresolved_comments.extend(conversation_comments);

    // Handle edge case: no unresolved comments
    if unresolved_comments.is_empty() {
        return PRContextResult::NoUnresolvedComments {
            number: pr_number,
            title,
            body,
            url,
        };
    }

    PRContextResult::Success(PRContext {
        number: pr_number,
        title,
        body,
        url,
        unresolved_comments,
    })
}

// ============================================================================
// US-003: Branch Context Gathering (Spec, Commits)
// ============================================================================

use crate::config;
use crate::output::{print_branch_context_summary, print_missing_spec_warning};
use std::path::PathBuf;

/// Context gathered from the branch (spec file and commits)
#[derive(Debug, Clone)]
pub struct BranchContext {
    /// The branch name
    pub branch_name: String,
    /// The loaded spec file (if found)
    pub spec: Option<Spec>,
    /// Path where spec was found or expected
    pub spec_path: PathBuf,
    /// Commits on this branch (excluding merge commits)
    pub commits: Vec<git::CommitInfo>,
}

/// Result of gathering branch context
#[derive(Debug, Clone)]
pub enum BranchContextResult {
    /// Successfully gathered branch context with spec
    SuccessWithSpec(BranchContext),
    /// Successfully gathered branch context but no spec found
    SuccessNoSpec(BranchContext),
    /// Error occurred during gathering
    Error(String),
}

/// Attempt to find a spec file for the given branch name.
///
/// Looks for spec files in `~/.config/autom8/<project>/spec/` that match
/// the branch name. The branch name is converted to a safe filename by
/// replacing `/` with `-`.
///
/// # Arguments
/// * `branch_name` - The branch name to find a spec for
///
/// # Returns
/// * `Ok(Some((spec, path)))` - Spec found and loaded
/// * `Ok(None)` - No spec file found
/// * `Err` - Error loading the spec (e.g., invalid JSON)
pub fn find_spec_for_branch(branch_name: &str) -> crate::error::Result<Option<(Spec, PathBuf)>> {
    // Get the spec directory for the current project
    let spec_dir = config::spec_dir()?;

    // Convert branch name to safe filename
    // e.g., "feature/pr-review" -> "feature-pr-review"
    let safe_branch_name = branch_name.replace('/', "-");

    // Try different filename patterns:
    // 1. spec-{branch}.json (e.g., spec-feature-pr-review.json)
    // 2. {branch}.json (e.g., feature-pr-review.json)
    let patterns = [
        format!("spec-{}.json", safe_branch_name),
        format!("{}.json", safe_branch_name),
    ];

    for pattern in &patterns {
        let spec_path = spec_dir.join(pattern);
        if spec_path.exists() {
            let spec = Spec::load(&spec_path)?;
            return Ok(Some((spec, spec_path)));
        }
    }

    // Also try to find any spec file where the branchName matches
    // This handles cases where the filename doesn't match but the content does
    if spec_dir.exists() {
        if let Ok(entries) = std::fs::read_dir(&spec_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().map_or(false, |ext| ext == "json") {
                    if let Ok(spec) = Spec::load(&path) {
                        if spec.branch_name == branch_name {
                            return Ok(Some((spec, path)));
                        }
                    }
                }
            }
        }
    }

    Ok(None)
}

/// Get the expected spec path for a branch (for error messages).
fn expected_spec_path(branch_name: &str) -> PathBuf {
    let safe_branch_name = branch_name.replace('/', "-");
    if let Ok(spec_dir) = config::spec_dir() {
        spec_dir.join(format!("spec-{}.json", safe_branch_name))
    } else {
        PathBuf::from(format!(
            "~/.config/autom8/<project>/spec/spec-{}.json",
            safe_branch_name
        ))
    }
}

/// Gather all branch context: spec file and commits.
///
/// This function attempts to load the spec file for the current branch
/// and fetches all non-merge commits specific to this branch.
///
/// # Arguments
/// * `show_warning` - Whether to display a prominent warning if no spec is found
///
/// # Returns
/// * `BranchContextResult::SuccessWithSpec` - Full context with spec loaded
/// * `BranchContextResult::SuccessNoSpec` - Context gathered but no spec found
/// * `BranchContextResult::Error` - Error occurred during gathering
pub fn gather_branch_context(show_warning: bool) -> BranchContextResult {
    // Get current branch
    let branch_name = match git::current_branch() {
        Ok(name) => name,
        Err(e) => {
            return BranchContextResult::Error(format!("Failed to get current branch: {}", e))
        }
    };

    // Try to find and load spec file
    let (spec, spec_path) = match find_spec_for_branch(&branch_name) {
        Ok(Some((spec, path))) => (Some(spec), path),
        Ok(None) => {
            let expected_path = expected_spec_path(&branch_name);
            if show_warning {
                print_missing_spec_warning(&branch_name, &expected_path.display().to_string());
            }
            (None, expected_path)
        }
        Err(e) => {
            // Spec file exists but failed to parse
            return BranchContextResult::Error(format!("Failed to load spec file: {}", e));
        }
    };

    // Get branch commits (excluding merge commits)
    let commits = match git::get_current_branch_commits() {
        Ok(commits) => commits,
        Err(e) => {
            // Non-fatal: continue without commits if git log fails
            // This can happen on new branches with no upstream
            eprintln!(
                "{}: Could not get branch commits: {}",
                crate::output::YELLOW,
                e
            );
            Vec::new()
        }
    };

    // Create context
    let context = BranchContext {
        branch_name: branch_name.clone(),
        spec,
        spec_path,
        commits,
    };

    // Return appropriate result
    if context.spec.is_some() {
        BranchContextResult::SuccessWithSpec(context)
    } else {
        BranchContextResult::SuccessNoSpec(context)
    }
}

/// Print a summary of the gathered branch context.
///
/// Convenience function that displays the context summary using the output module.
pub fn print_branch_context(context: &BranchContext) {
    print_branch_context_summary(
        context.spec.is_some(),
        context.commits.len(),
        &context.branch_name,
    );
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::UserStory;

    #[test]
    fn test_format_pr_description_basic() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "A test feature description.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "First Story".to_string(),
                description: "This is the first story.".to_string(),
                acceptance_criteria: vec!["Criterion 1".to_string()],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Summary"));
        assert!(result.contains("A test feature description."));
        // Incomplete story should appear under "Changes" section
        assert!(result.contains("## Changes"));
        assert!(result.contains("### US-001: First Story"));
        assert!(result.contains("This is the first story."));
    }

    #[test]
    fn test_format_pr_description_multiple_stories_mixed() {
        // Mixed completion status: completed story first, incomplete second
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Multi-story feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Story One".to_string(),
                    description: "First description.".to_string(),
                    acceptance_criteria: vec![],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Story Two".to_string(),
                    description: "Second description.".to_string(),
                    acceptance_criteria: vec![],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Verify both stories are included
        assert!(result.contains("### US-001: Story One"));
        assert!(result.contains("First description."));
        assert!(result.contains("### US-002: Story Two"));
        assert!(result.contains("Second description."));

        // Verify structure order: Summary -> Completed -> Remaining
        let summary_pos = result.find("## Summary").unwrap();
        let completed_pos = result.find("## Completed").unwrap();
        let remaining_pos = result.find("## Remaining").unwrap();
        assert!(summary_pos < completed_pos);
        assert!(completed_pos < remaining_pos);

        // Completed story should be under Completed section
        let story_one_pos = result.find("### US-001").unwrap();
        assert!(story_one_pos > completed_pos && story_one_pos < remaining_pos);

        // Incomplete story should be under Remaining section
        let story_two_pos = result.find("### US-002").unwrap();
        assert!(story_two_pos > remaining_pos);
    }

    #[test]
    fn test_format_pr_description_with_newlines_in_description() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Line one.\nLine two.\nLine three.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test".to_string(),
                description: "Story line one.\nStory line two.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Newlines should be preserved in the output
        assert!(result.contains("Line one.\nLine two.\nLine three."));
        assert!(result.contains("Story line one.\nStory line two."));
    }

    #[test]
    fn test_format_pr_description_output_is_clean() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Clean output test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Clean".to_string(),
                description: "Clean story.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should not have excessive trailing whitespace
        assert!(!result.ends_with("\n\n"));
        // Should start with ## Summary
        assert!(result.starts_with("## Summary"));
    }

    // ========================================================================
    // US-001: Acceptance criteria as checkboxes tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_acceptance_criteria_unchecked() {
        // Incomplete story (passes: false) should show unchecked boxes
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test Story".to_string(),
                description: "A test story.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [ ] First criterion"));
        assert!(result.contains("- [ ] Second criterion"));
        // Should NOT contain checked boxes
        assert!(!result.contains("- [x]"));
    }

    #[test]
    fn test_format_pr_description_acceptance_criteria_checked() {
        // Completed story (passes: true) should show checked boxes
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Completed Story".to_string(),
                description: "A completed story.".to_string(),
                acceptance_criteria: vec![
                    "Done criterion".to_string(),
                    "Also done criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [x] Done criterion"));
        assert!(result.contains("- [x] Also done criterion"));
        // Should NOT contain unchecked boxes
        assert!(!result.contains("- [ ]"));
    }

    #[test]
    fn test_format_pr_description_empty_acceptance_criteria_skipped() {
        // Story with empty acceptance_criteria should not show the section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story Without Criteria".to_string(),
                description: "No acceptance criteria here.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain acceptance criteria section
        assert!(!result.contains("**Acceptance Criteria:**"));
        assert!(!result.contains("- [ ]"));
        assert!(!result.contains("- [x]"));
        // Story content should still be present
        assert!(result.contains("### US-001: Story Without Criteria"));
        assert!(result.contains("No acceptance criteria here."));
    }

    #[test]
    fn test_format_pr_description_mixed_story_statuses() {
        // Multiple stories with different passes status
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Mixed status feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Complete Story".to_string(),
                    description: "This one is done.".to_string(),
                    acceptance_criteria: vec!["Completed criterion".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Incomplete Story".to_string(),
                    description: "This one is not done.".to_string(),
                    acceptance_criteria: vec!["Pending criterion".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // First story should have checked boxes
        assert!(result.contains("- [x] Completed criterion"));
        // Second story should have unchecked boxes
        assert!(result.contains("- [ ] Pending criterion"));
    }

    #[test]
    fn test_format_pr_description_acceptance_criteria_order_preserved() {
        // Criteria should appear in the same order as in the spec
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Ordered Story".to_string(),
                description: "Check order.".to_string(),
                acceptance_criteria: vec![
                    "First".to_string(),
                    "Second".to_string(),
                    "Third".to_string(),
                ],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Verify order by checking positions
        let first_pos = result.find("- [ ] First").unwrap();
        let second_pos = result.find("- [ ] Second").unwrap();
        let third_pos = result.find("- [ ] Third").unwrap();
        assert!(first_pos < second_pos);
        assert!(second_pos < third_pos);
    }

    // ========================================================================
    // US-002: Separate completed and incomplete stories tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_all_stories_complete() {
        // When all stories are complete, show "Completed" section only (no "Remaining")
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "All complete feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "First Complete".to_string(),
                    description: "First done.".to_string(),
                    acceptance_criteria: vec!["Criterion A".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Second Complete".to_string(),
                    description: "Second done.".to_string(),
                    acceptance_criteria: vec!["Criterion B".to_string()],
                    priority: 2,
                    passes: true,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have "Completed" section
        assert!(result.contains("## Completed"));
        // Should NOT have "Remaining" or "Changes" sections
        assert!(!result.contains("## Remaining"));
        assert!(!result.contains("## Changes"));
        // Both stories should be present under Completed
        assert!(result.contains("### US-001: First Complete"));
        assert!(result.contains("### US-002: Second Complete"));
        // All checkboxes should be checked
        assert!(result.contains("- [x] Criterion A"));
        assert!(result.contains("- [x] Criterion B"));
    }

    #[test]
    fn test_format_pr_description_no_stories_complete() {
        // When no stories are complete, show all under "Changes" (not "Completed" or "Remaining")
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Nothing complete yet.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "First Incomplete".to_string(),
                    description: "Not done yet.".to_string(),
                    acceptance_criteria: vec!["Pending A".to_string()],
                    priority: 1,
                    passes: false,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Second Incomplete".to_string(),
                    description: "Also not done.".to_string(),
                    acceptance_criteria: vec!["Pending B".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have "Changes" section
        assert!(result.contains("## Changes"));
        // Should NOT have "Completed" or "Remaining" sections
        assert!(!result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        // Both stories should be present under Changes
        assert!(result.contains("### US-001: First Incomplete"));
        assert!(result.contains("### US-002: Second Incomplete"));
        // All checkboxes should be unchecked
        assert!(result.contains("- [ ] Pending A"));
        assert!(result.contains("- [ ] Pending B"));
    }

    #[test]
    fn test_format_pr_description_mixed_completion_status() {
        // Mixed: some complete, some incomplete - show both sections
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Partially complete feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Done Story".to_string(),
                    description: "This is done.".to_string(),
                    acceptance_criteria: vec!["Done criterion".to_string()],
                    priority: 1,
                    passes: true,
                    notes: String::new(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Pending Story".to_string(),
                    description: "Not done yet.".to_string(),
                    acceptance_criteria: vec!["Pending criterion".to_string()],
                    priority: 2,
                    passes: false,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // Should have both "Completed" and "Remaining" sections
        assert!(result.contains("## Completed"));
        assert!(result.contains("## Remaining"));
        // Should NOT have "Changes" section
        assert!(!result.contains("## Changes"));

        // Verify correct section ordering
        let completed_pos = result.find("## Completed").unwrap();
        let remaining_pos = result.find("## Remaining").unwrap();
        assert!(completed_pos < remaining_pos);

        // Completed story in Completed section
        let done_story_pos = result.find("### US-001: Done Story").unwrap();
        assert!(done_story_pos > completed_pos && done_story_pos < remaining_pos);

        // Incomplete story in Remaining section
        let pending_story_pos = result.find("### US-002: Pending Story").unwrap();
        assert!(pending_story_pos > remaining_pos);

        // Checkboxes match completion status
        assert!(result.contains("- [x] Done criterion"));
        assert!(result.contains("- [ ] Pending criterion"));
    }

    #[test]
    fn test_format_pr_description_story_content_in_sections() {
        // Verify each story shows ID, title, description, and acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Content verification test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-042".to_string(),
                title: "Detailed Story".to_string(),
                description: "A story with full details.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Story header: ### US-042: Detailed Story
        assert!(result.contains("### US-042: Detailed Story"));
        // Description
        assert!(result.contains("A story with full details."));
        // Acceptance criteria header and items
        assert!(result.contains("**Acceptance Criteria:**"));
        assert!(result.contains("- [x] First criterion"));
        assert!(result.contains("- [x] Second criterion"));
    }

    #[test]
    fn test_format_pr_description_single_complete_story() {
        // Single complete story should show "Completed" section, no "Remaining"
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Single story feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Only Story".to_string(),
                description: "The one and only.".to_string(),
                acceptance_criteria: vec!["It works".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        assert!(!result.contains("## Changes"));
        assert!(result.contains("### US-001: Only Story"));
    }

    #[test]
    fn test_format_pr_description_single_incomplete_story() {
        // Single incomplete story should show "Changes" section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Single incomplete feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Incomplete Story".to_string(),
                description: "Still working on it.".to_string(),
                acceptance_criteria: vec!["To be done".to_string()],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("## Changes"));
        assert!(!result.contains("## Completed"));
        assert!(!result.contains("## Remaining"));
        assert!(result.contains("### US-001: Incomplete Story"));
    }

    #[test]
    fn test_is_gh_installed_returns_bool() {
        // This test just verifies the function runs without panicking
        // and returns a boolean (actual result depends on system)
        let result = is_gh_installed();
        assert!(result || !result); // Always true, just confirms it returns bool
    }

    #[test]
    fn test_is_gh_authenticated_returns_bool() {
        // This test verifies the function runs without panicking
        let result = is_gh_authenticated();
        assert!(result || !result);
    }

    #[test]
    fn test_pr_exists_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = pr_exists_for_branch("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
    }

    #[test]
    fn test_get_existing_pr_url_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = get_existing_pr_url("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
        // Should return None since no PR exists
        if let Ok(url) = result {
            assert!(url.is_none());
        }
    }

    #[test]
    fn test_pr_exists_handles_empty_json_array() {
        // Verify our parsing logic handles empty arrays correctly
        let empty_json = "[]";
        let trimmed = empty_json.trim();
        assert_eq!(trimmed, "[]");
        assert!(trimmed == "[]" || trimmed.is_empty());
    }

    #[test]
    fn test_get_existing_pr_url_parses_json_correctly() {
        // Test the JSON parsing logic
        let json_str = r#"[{"url":"https://github.com/owner/repo/pull/123"}]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();
        assert!(!parsed.is_empty());
        let url = parsed[0].get("url").and_then(|v| v.as_str());
        assert_eq!(url, Some("https://github.com/owner/repo/pull/123"));
    }

    #[test]
    fn test_pr_result_success_contains_url() {
        let url = "https://github.com/owner/repo/pull/42".to_string();
        let result = PRResult::Success(url.clone());
        assert_eq!(result, PRResult::Success(url));
    }

    #[test]
    fn test_pr_result_skipped_contains_reason() {
        let reason = "gh CLI not installed".to_string();
        let result = PRResult::Skipped(reason.clone());
        assert_eq!(result, PRResult::Skipped(reason));
    }

    #[test]
    fn test_pr_result_already_exists_contains_url() {
        let url = "https://github.com/owner/repo/pull/99".to_string();
        let result = PRResult::AlreadyExists(url.clone());
        assert_eq!(result, PRResult::AlreadyExists(url));
    }

    #[test]
    fn test_pr_result_error_contains_message() {
        let message = "Failed to create PR: permission denied".to_string();
        let result = PRResult::Error(message.clone());
        assert_eq!(result, PRResult::Error(message));
    }

    #[test]
    fn test_pr_result_variants_are_distinct() {
        let url = "https://github.com/owner/repo/pull/1".to_string();
        let success = PRResult::Success(url.clone());
        let skipped = PRResult::Skipped(url.clone());
        let already_exists = PRResult::AlreadyExists(url.clone());
        let updated = PRResult::Updated(url.clone());
        let error = PRResult::Error(url.clone());

        // Each variant should be distinct even with the same inner value
        assert_ne!(success, skipped);
        assert_ne!(success, already_exists);
        assert_ne!(success, updated);
        assert_ne!(success, error);
        assert_ne!(skipped, already_exists);
        assert_ne!(skipped, updated);
        assert_ne!(skipped, error);
        assert_ne!(already_exists, updated);
        assert_ne!(already_exists, error);
        assert_ne!(updated, error);
    }

    #[test]
    fn test_pr_result_clone() {
        let original = PRResult::Success("https://github.com/owner/repo/pull/5".to_string());
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_create_pull_request_skips_when_no_commits() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());

        match result.unwrap() {
            PRResult::Skipped(reason) => {
                assert!(reason.contains("No commits"));
            }
            _ => panic!("Expected PRResult::Skipped"),
        }
    }

    #[test]
    fn test_create_pull_request_returns_result() {
        // This test verifies the function runs without panicking
        // and returns a valid Result (actual outcome depends on environment)
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, true);
        assert!(result.is_ok());

        // The result should be one of the valid PRResult variants
        let pr_result = result.unwrap();
        match pr_result {
            PRResult::Success(_)
            | PRResult::Skipped(_)
            | PRResult::AlreadyExists(_)
            | PRResult::Updated(_)
            | PRResult::Error(_) => {}
        }
    }

    #[test]
    fn test_create_pull_request_checks_prerequisites_in_order() {
        // Test that commits_were_made is checked first
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // When commits_were_made is false, should skip immediately
        // regardless of other conditions
        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());

        if let Ok(PRResult::Skipped(reason)) = result {
            assert!(
                reason.contains("No commits"),
                "Should skip due to no commits first"
            );
        } else {
            panic!("Expected Skipped result for no commits");
        }
    }

    #[test]
    fn test_create_pull_request_with_commits_checks_git_repo() {
        // When commits_were_made is true, the function should proceed
        // to check git repo status (we're in a git repo, so it passes)
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, true);
        assert!(result.is_ok());

        // Should not return "No commits" skip since commits_were_made is true
        if let Ok(PRResult::Skipped(reason)) = &result {
            assert!(
                !reason.contains("No commits"),
                "Should not skip due to commits when commits_were_made is true"
            );
        }
    }

    #[test]
    fn test_create_pull_request_function_signature() {
        // Verify the function signature matches the acceptance criteria
        fn _check_signature(_spec: &Spec, _commits: bool) -> Result<PRResult> {
            create_pull_request(_spec, _commits)
        }

        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // This test just verifies compilation with the correct signature
        let _ = _check_signature(&spec, false);
    }

    #[test]
    fn test_create_pull_request_uses_spec_description_as_title() {
        // The function uses spec.description as the PR title
        // We can't easily test the actual gh command, but we verify
        // the function has access to the spec and doesn't panic
        let spec = Spec {
            project: "my-project".to_string(),
            branch_name: "feature/awesome".to_string(),
            description: "Add awesome feature with multiple components".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Awesome Story".to_string(),
                description: "Make it awesome".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        // Just verify the function accepts the spec correctly
        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());
    }

    // ========================================================================
    // US-000: Push before PR creation tests
    // ========================================================================

    #[test]
    fn test_create_pull_request_order_of_operations() {
        // This test documents the expected order of operations in create_pull_request:
        // 1. Check commits_were_made
        // 2. Check git repo
        // 3. Check gh installed
        // 4. Check gh authenticated
        // 5. Check not on main/master
        // 6. Check PR doesn't already exist
        // 7. Push branch to remote <-- NEW STEP
        // 8. Create PR
        //
        // The push step (7) must happen BEFORE the gh pr create call (8).
        // This is verified by the code structure and this documentation test.

        // When commits_were_made is false, we never reach the push step
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        let result = create_pull_request(&spec, false);
        assert!(result.is_ok());
        // Should skip due to no commits, never reaching push or PR creation
        if let Ok(PRResult::Skipped(reason)) = result {
            assert!(reason.contains("No commits"));
        }
    }

    #[test]
    fn test_push_result_error_propagates_as_pr_error() {
        // When push fails, create_pull_request should return PRResult::Error
        // This test documents the expected behavior - actual testing would require
        // mocking git operations which is not easily done in unit tests.

        // The implementation handles push failure by returning:
        // PRResult::Error(format!("Failed to push branch: {}", msg))
        //
        // This is the expected behavior based on acceptance criteria:
        // "If push fails, transition to Failed state with a clear error message"

        use crate::git::PushResult;

        let error_msg = "remote rejected";
        let push_error = PushResult::Error(error_msg.to_string());
        assert!(matches!(push_error, PushResult::Error(_)));
    }

    // ========================================================================
    // US-003: Implementation notes in PR description tests
    // ========================================================================

    #[test]
    fn test_format_pr_description_notes_included_when_present() {
        // Story with non-empty notes should show the notes section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story With Notes".to_string(),
                description: "A story that has implementation notes.".to_string(),
                acceptance_criteria: vec!["Some criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "This is an important implementation note for reviewers.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("**Notes:**"));
        assert!(result.contains("This is an important implementation note for reviewers."));
    }

    #[test]
    fn test_format_pr_description_notes_excluded_when_empty() {
        // Story with empty notes should NOT show the notes section
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Story Without Notes".to_string(),
                description: "A story with no notes.".to_string(),
                acceptance_criteria: vec!["Some criterion".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain notes section
        assert!(!result.contains("**Notes:**"));
        // Story content should still be present
        assert!(result.contains("### US-001: Story Without Notes"));
        assert!(result.contains("A story with no notes."));
    }

    #[test]
    fn test_format_pr_description_notes_appear_after_acceptance_criteria() {
        // Notes should appear after acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Ordered Story".to_string(),
                description: "Check ordering.".to_string(),
                acceptance_criteria: vec!["First criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "Implementation context here.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Verify ordering: Acceptance Criteria before Notes
        let criteria_pos = result.find("**Acceptance Criteria:**").unwrap();
        let notes_pos = result.find("**Notes:**").unwrap();
        assert!(
            criteria_pos < notes_pos,
            "Acceptance Criteria should appear before Notes"
        );
    }

    #[test]
    fn test_format_pr_description_notes_with_no_acceptance_criteria() {
        // Notes should still appear even if there are no acceptance criteria
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Notes Only Story".to_string(),
                description: "Story with notes but no criteria.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: true,
                notes: "These notes stand alone.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should NOT contain acceptance criteria section
        assert!(!result.contains("**Acceptance Criteria:**"));
        // Should contain notes section
        assert!(result.contains("**Notes:**"));
        assert!(result.contains("These notes stand alone."));
    }

    #[test]
    fn test_format_pr_description_notes_multiline() {
        // Multi-line notes should be preserved
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Multiline Notes".to_string(),
                description: "Story with detailed notes.".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: true,
                notes: "Line one of notes.\nLine two of notes.\nLine three.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        assert!(result.contains("Line one of notes.\nLine two of notes.\nLine three."));
    }

    #[test]
    fn test_format_pr_description_mixed_stories_with_and_without_notes() {
        // Multiple stories: some with notes, some without
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Mixed notes feature.".to_string(),
            user_stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "Story With Notes".to_string(),
                    description: "Has notes.".to_string(),
                    acceptance_criteria: vec!["Criterion A".to_string()],
                    priority: 1,
                    passes: true,
                    notes: "Important context for US-001.".to_string(),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "Story Without Notes".to_string(),
                    description: "No notes here.".to_string(),
                    acceptance_criteria: vec!["Criterion B".to_string()],
                    priority: 2,
                    passes: true,
                    notes: String::new(),
                },
            ],
        };

        let result = format_pr_description(&spec);

        // First story should have notes
        assert!(result.contains("Important context for US-001."));
        // Should have exactly one **Notes:** section (for US-001 only)
        assert_eq!(result.matches("**Notes:**").count(), 1);
    }

    #[test]
    fn test_format_pr_description_no_double_blank_lines_with_notes() {
        // Verify clean formatting without excessive whitespace
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Clean formatting test.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Clean Story".to_string(),
                description: "Clean description.".to_string(),
                acceptance_criteria: vec!["Clean criterion".to_string()],
                priority: 1,
                passes: true,
                notes: "Clean notes.".to_string(),
            }],
        };

        let result = format_pr_description(&spec);

        // Should not have triple newlines (which would indicate double blank lines)
        assert!(
            !result.contains("\n\n\n"),
            "Should not have double blank lines"
        );
    }

    // ========================================================================
    // US-004: Update existing PR description tests
    // ========================================================================

    #[test]
    fn test_pr_result_updated_contains_url() {
        let url = "https://github.com/owner/repo/pull/42".to_string();
        let result = PRResult::Updated(url.clone());
        assert_eq!(result, PRResult::Updated(url));
    }

    #[test]
    fn test_pr_result_updated_clone() {
        let original = PRResult::Updated("https://github.com/owner/repo/pull/5".to_string());
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_get_existing_pr_number_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = get_existing_pr_number("nonexistent-branch-that-does-not-exist-12345");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
        // Should return None since no PR exists
        if let Ok(number) = result {
            assert!(number.is_none());
        }
    }

    #[test]
    fn test_get_existing_pr_number_parses_json_correctly() {
        // Test the JSON parsing logic
        let json_str = r#"[{"number":123}]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();
        assert!(!parsed.is_empty());
        let number = parsed[0].get("number").and_then(|v| v.as_u64());
        assert_eq!(number, Some(123));
    }

    #[test]
    fn test_get_existing_pr_number_handles_empty_json_array() {
        // Verify our parsing logic handles empty arrays correctly
        let empty_json = "[]";
        let trimmed = empty_json.trim();
        assert_eq!(trimmed, "[]");
        assert!(trimmed == "[]" || trimmed.is_empty());
    }

    #[test]
    fn test_update_pr_description_function_signature() {
        // Verify the function signature matches the acceptance criteria
        fn _check_signature(_spec: &Spec, _pr_number: u32) -> Result<PRResult> {
            update_pr_description(_spec, _pr_number)
        }

        let spec = Spec {
            project: "test".to_string(),
            branch_name: "test".to_string(),
            description: "Test".to_string(),
            user_stories: vec![],
        };

        // This test just verifies compilation with the correct signature
        let _ = _check_signature(&spec, 123);
    }

    #[test]
    fn test_update_pr_description_returns_result() {
        // This test verifies the function runs without panicking
        // and returns a valid Result (actual outcome depends on environment)
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test Story".to_string(),
                description: "A test.".to_string(),
                acceptance_criteria: vec!["Criterion".to_string()],
                priority: 1,
                passes: true,
                notes: String::new(),
            }],
        };

        let result = update_pr_description(&spec, 99999);
        assert!(result.is_ok());

        // The result should be either Updated or Error (depending on gh availability)
        let pr_result = result.unwrap();
        match pr_result {
            PRResult::Updated(_) | PRResult::Error(_) => {}
            _ => panic!("Expected Updated or Error variant"),
        }
    }

    #[test]
    fn test_update_pr_description_uses_format_pr_description() {
        // Verify that update_pr_description uses the same formatting as create_pull_request
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test feature for update.".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Updated Story".to_string(),
                description: "This story was updated.".to_string(),
                acceptance_criteria: vec![
                    "First criterion".to_string(),
                    "Second criterion".to_string(),
                ],
                priority: 1,
                passes: true,
                notes: "Important notes for reviewers.".to_string(),
            }],
        };

        // Generate the expected body
        let expected_body = format_pr_description(&spec);

        // Verify the expected body contains all the expected elements
        assert!(expected_body.contains("## Summary"));
        assert!(expected_body.contains("Test feature for update."));
        assert!(expected_body.contains("### US-001: Updated Story"));
        assert!(expected_body.contains("- [x] First criterion"));
        assert!(expected_body.contains("- [x] Second criterion"));
        assert!(expected_body.contains("**Notes:**"));
        assert!(expected_body.contains("Important notes for reviewers."));
    }

    // ========================================================================
    // US-005: PR title formatting tests
    // ========================================================================

    #[test]
    fn test_format_pr_title_basic() {
        // Simple single-line description
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Add user authentication".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Add user authentication");
    }

    #[test]
    fn test_format_pr_title_with_project_prefix() {
        // Project field should prefix the title
        let spec = Spec {
            project: "autom8".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Add user authentication".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "[autom8] Add user authentication");
    }

    #[test]
    fn test_format_pr_title_multiline_uses_first_line() {
        // Multi-line description should use only the first line
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description:
                "Improve PR descriptions\nThis is a longer explanation.\nAnd more details."
                    .to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Improve PR descriptions");
    }

    #[test]
    fn test_format_pr_title_single_line_uses_first_sentence() {
        // Single-line description with multiple sentences should use first sentence
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Add feature X. This feature does something important. It helps users."
                .to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title, "Add feature X.");
    }

    #[test]
    fn test_format_pr_title_truncation_at_72_chars() {
        // Title longer than 72 characters should be truncated with "..."
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that definitely exceeds the seventy-two character limit for PR titles".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_truncation_at_word_boundary() {
        // Truncation should try to happen at word boundaries
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that definitely exceeds the seventy-two character limit".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.ends_with("..."));
        // Should not cut in the middle of a word
        assert!(!title.ends_with("seven..."));
    }

    #[test]
    fn test_format_pr_title_with_project_truncation() {
        // Project prefix + long title should still truncate to 72 chars total
        let spec = Spec {
            project: "myproject".to_string(),
            branch_name: "feature/test".to_string(),
            description: "This is a very long description that will exceed the limit when combined with the project prefix".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(title.len() <= 72);
        assert!(title.starts_with("[myproject]"));
        assert!(title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_exactly_72_chars_no_truncation() {
        // Title that is exactly 72 characters should not be truncated
        let desc = "A".repeat(72);
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: desc.clone(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert_eq!(title.len(), 72);
        assert!(!title.ends_with("..."));
    }

    #[test]
    fn test_format_pr_title_empty_project_no_prefix() {
        // Empty project field should not add prefix
        let spec = Spec {
            project: String::new(),
            branch_name: "feature/test".to_string(),
            description: "Simple title".to_string(),
            user_stories: vec![],
        };

        let title = format_pr_title(&spec);
        assert!(!title.starts_with("["));
        assert_eq!(title, "Simple title");
    }

    #[test]
    fn test_extract_first_line_or_sentence_multiline() {
        let text = "First line here\nSecond line\nThird line";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "First line here");
    }

    #[test]
    fn test_extract_first_line_or_sentence_single_sentence() {
        let text = "This is a sentence. This is another. And one more.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "This is a sentence.");
    }

    #[test]
    fn test_extract_first_line_or_sentence_no_boundaries() {
        let text = "Just some text without periods or newlines";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "Just some text without periods or newlines");
    }

    #[test]
    fn test_extract_first_line_or_sentence_exclamation() {
        let text = "Important announcement! More details here.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "Important announcement!");
    }

    #[test]
    fn test_extract_first_line_or_sentence_question() {
        let text = "What is this? It's a test.";
        let result = extract_first_line_or_sentence(text);
        assert_eq!(result, "What is this?");
    }

    #[test]
    fn test_truncate_with_ellipsis_short_text() {
        let text = "Short text";
        let result = truncate_with_ellipsis(text, 72);
        assert_eq!(result, "Short text");
    }

    #[test]
    fn test_truncate_with_ellipsis_long_text() {
        let text = "This is a very long text that needs to be truncated because it exceeds the maximum allowed length";
        let result = truncate_with_ellipsis(text, 50);
        assert!(result.len() <= 50);
        assert!(result.ends_with("..."));
    }

    #[test]
    fn test_truncate_with_ellipsis_word_boundary() {
        let text = "Hello world this is a test";
        let result = truncate_with_ellipsis(text, 20);
        // Should truncate at word boundary
        assert_eq!(result, "Hello world this...");
    }

    #[test]
    fn test_format_pr_title_full_description_in_body() {
        // Verify that the full description is preserved in the body
        let long_desc = "First line of description.\nSecond line with more details.\nThird line with even more context.";
        let spec = Spec {
            project: "test".to_string(),
            branch_name: "feature/test".to_string(),
            description: long_desc.to_string(),
            user_stories: vec![],
        };

        // Title should be just the first line
        let title = format_pr_title(&spec);
        assert_eq!(title, "[test] First line of description.");

        // Body should contain the full description
        let body = format_pr_description(&spec);
        assert!(body.contains(long_desc));
    }

    // ========================================================================
    // US-001: PR Detection tests
    // ========================================================================

    #[test]
    fn test_pull_request_info_struct() {
        let pr = PullRequestInfo {
            number: 42,
            title: "Add feature X".to_string(),
            head_branch: "feature/x".to_string(),
            url: "https://github.com/owner/repo/pull/42".to_string(),
        };

        assert_eq!(pr.number, 42);
        assert_eq!(pr.title, "Add feature X");
        assert_eq!(pr.head_branch, "feature/x");
        assert_eq!(pr.url, "https://github.com/owner/repo/pull/42");
    }

    #[test]
    fn test_pull_request_info_clone() {
        let pr = PullRequestInfo {
            number: 123,
            title: "Test PR".to_string(),
            head_branch: "test-branch".to_string(),
            url: "https://example.com".to_string(),
        };
        let cloned = pr.clone();
        assert_eq!(pr, cloned);
    }

    #[test]
    fn test_pull_request_info_equality() {
        let pr1 = PullRequestInfo {
            number: 1,
            title: "PR 1".to_string(),
            head_branch: "branch-1".to_string(),
            url: "url-1".to_string(),
        };
        let pr2 = PullRequestInfo {
            number: 1,
            title: "PR 1".to_string(),
            head_branch: "branch-1".to_string(),
            url: "url-1".to_string(),
        };
        let pr3 = PullRequestInfo {
            number: 2,
            title: "PR 2".to_string(),
            head_branch: "branch-2".to_string(),
            url: "url-2".to_string(),
        };

        assert_eq!(pr1, pr2);
        assert_ne!(pr1, pr3);
    }

    #[test]
    fn test_pr_detection_result_found_variant() {
        let pr = PullRequestInfo {
            number: 42,
            title: "Test PR".to_string(),
            head_branch: "feature/test".to_string(),
            url: "https://example.com/pull/42".to_string(),
        };
        let result = PRDetectionResult::Found(pr.clone());
        assert_eq!(result, PRDetectionResult::Found(pr));
    }

    #[test]
    fn test_pr_detection_result_on_main_branch_variant() {
        let result = PRDetectionResult::OnMainBranch;
        assert_eq!(result, PRDetectionResult::OnMainBranch);
    }

    #[test]
    fn test_pr_detection_result_no_pr_for_branch_variant() {
        let result = PRDetectionResult::NoPRForBranch("feature/x".to_string());
        assert_eq!(
            result,
            PRDetectionResult::NoPRForBranch("feature/x".to_string())
        );
    }

    #[test]
    fn test_pr_detection_result_error_variant() {
        let result = PRDetectionResult::Error("gh not installed".to_string());
        assert_eq!(
            result,
            PRDetectionResult::Error("gh not installed".to_string())
        );
    }

    #[test]
    fn test_pr_detection_result_variants_are_distinct() {
        let pr = PullRequestInfo {
            number: 1,
            title: "Test".to_string(),
            head_branch: "test".to_string(),
            url: "url".to_string(),
        };
        let found = PRDetectionResult::Found(pr);
        let on_main = PRDetectionResult::OnMainBranch;
        let no_pr = PRDetectionResult::NoPRForBranch("test".to_string());
        let error = PRDetectionResult::Error("error".to_string());

        assert_ne!(found, on_main);
        assert_ne!(found, no_pr);
        assert_ne!(found, error);
        assert_ne!(on_main, no_pr);
        assert_ne!(on_main, error);
        assert_ne!(no_pr, error);
    }

    #[test]
    fn test_pr_detection_result_clone() {
        let pr = PullRequestInfo {
            number: 5,
            title: "Clone Test".to_string(),
            head_branch: "clone".to_string(),
            url: "url".to_string(),
        };
        let original = PRDetectionResult::Found(pr);
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_check_gh_prerequisites_returns_result() {
        // This test verifies the function runs without panicking
        // and returns a valid Result (actual outcome depends on system)
        let result = check_gh_prerequisites();
        // Should be Ok or Err with a message
        match result {
            Ok(()) => {}
            Err(msg) => {
                assert!(!msg.is_empty());
            }
        }
    }

    #[test]
    fn test_detect_pr_for_current_branch_returns_result() {
        // This test verifies the function runs without panicking
        // Actual outcome depends on system configuration
        let result = detect_pr_for_current_branch();
        assert!(result.is_ok());

        // Result should be one of the valid variants
        match result.unwrap() {
            PRDetectionResult::Found(_)
            | PRDetectionResult::OnMainBranch
            | PRDetectionResult::NoPRForBranch(_)
            | PRDetectionResult::Error(_) => {}
        }
    }

    #[test]
    fn test_get_pr_info_for_nonexistent_branch() {
        // Test with a branch name that almost certainly doesn't have a PR
        let result = get_pr_info_for_branch("nonexistent-branch-that-does-not-exist-99999");
        // Should return Ok (not panic) regardless of gh installation
        assert!(result.is_ok());
    }

    #[test]
    fn test_list_open_prs_returns_result() {
        // This test verifies the function runs without panicking
        // If gh is installed and authenticated, returns a list (may be empty)
        // If not, returns an error
        let result = list_open_prs();
        // Function should complete without panic
        match result {
            Ok(prs) => {
                // Valid result - list may be empty or have PRs
                for pr in prs {
                    assert!(pr.number > 0 || pr.number == 0); // Just verify it's a valid number
                }
            }
            Err(_) => {
                // Error is acceptable if gh is not configured
            }
        }
    }

    #[test]
    fn test_pr_info_json_parsing() {
        // Test the JSON parsing logic used by get_pr_info_for_branch
        let json_str = r#"[{"number":42,"title":"Test PR","headRefName":"feature/test","url":"https://github.com/owner/repo/pull/42"}]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();

        assert!(!parsed.is_empty());
        let pr = &parsed[0];

        let number = pr.get("number").and_then(|v| v.as_u64()).unwrap_or(0) as u32;
        let title = pr.get("title").and_then(|v| v.as_str()).unwrap_or("");
        let head_branch = pr.get("headRefName").and_then(|v| v.as_str()).unwrap_or("");
        let url = pr.get("url").and_then(|v| v.as_str()).unwrap_or("");

        assert_eq!(number, 42);
        assert_eq!(title, "Test PR");
        assert_eq!(head_branch, "feature/test");
        assert_eq!(url, "https://github.com/owner/repo/pull/42");
    }

    #[test]
    fn test_pr_info_json_parsing_empty_array() {
        let json_str = "[]";
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();
        assert!(parsed.is_empty());
    }

    #[test]
    fn test_pr_info_json_parsing_multiple_prs() {
        // Test parsing multiple PRs (like list_open_prs would return)
        let json_str = r#"[
            {"number":1,"title":"First PR","headRefName":"branch-1","url":"url-1"},
            {"number":2,"title":"Second PR","headRefName":"branch-2","url":"url-2"},
            {"number":3,"title":"Third PR","headRefName":"branch-3","url":"url-3"}
        ]"#;
        let parsed: Vec<serde_json::Value> = serde_json::from_str(json_str).unwrap();

        assert_eq!(parsed.len(), 3);

        let prs: Vec<PullRequestInfo> = parsed
            .iter()
            .map(|pr| PullRequestInfo {
                number: pr.get("number").and_then(|v| v.as_u64()).unwrap_or(0) as u32,
                title: pr
                    .get("title")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string(),
                head_branch: pr
                    .get("headRefName")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string(),
                url: pr
                    .get("url")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string(),
            })
            .collect();

        assert_eq!(prs.len(), 3);
        assert_eq!(prs[0].number, 1);
        assert_eq!(prs[1].number, 2);
        assert_eq!(prs[2].number, 3);
    }

    // ========================================================================
    // US-002: PR Context Gathering Tests
    // ========================================================================

    #[test]
    fn test_pr_comment_struct() {
        let comment = PRComment {
            author: "testuser".to_string(),
            body: "This is a test comment".to_string(),
            file_path: Some("src/main.rs".to_string()),
            line: Some(42),
            id: 12345,
            url: "https://github.com/owner/repo/pull/1#discussion_r12345".to_string(),
        };

        assert_eq!(comment.author, "testuser");
        assert_eq!(comment.body, "This is a test comment");
        assert_eq!(comment.file_path, Some("src/main.rs".to_string()));
        assert_eq!(comment.line, Some(42));
        assert_eq!(comment.id, 12345);
        assert!(comment.url.contains("discussion_r12345"));
    }

    #[test]
    fn test_pr_comment_without_file_context() {
        // Conversation comments don't have file/line context
        let comment = PRComment {
            author: "reviewer".to_string(),
            body: "General feedback".to_string(),
            file_path: None,
            line: None,
            id: 67890,
            url: "https://github.com/owner/repo/pull/1#issuecomment-67890".to_string(),
        };

        assert!(comment.file_path.is_none());
        assert!(comment.line.is_none());
    }

    #[test]
    fn test_pr_comment_clone() {
        let original = PRComment {
            author: "user".to_string(),
            body: "Comment".to_string(),
            file_path: Some("file.rs".to_string()),
            line: Some(10),
            id: 1,
            url: "url".to_string(),
        };
        let cloned = original.clone();
        assert_eq!(original, cloned);
    }

    #[test]
    fn test_pr_comment_equality() {
        let comment1 = PRComment {
            author: "user".to_string(),
            body: "Same".to_string(),
            file_path: None,
            line: None,
            id: 1,
            url: "url".to_string(),
        };
        let comment2 = PRComment {
            author: "user".to_string(),
            body: "Same".to_string(),
            file_path: None,
            line: None,
            id: 1,
            url: "url".to_string(),
        };
        let comment3 = PRComment {
            author: "different".to_string(),
            body: "Same".to_string(),
            file_path: None,
            line: None,
            id: 1,
            url: "url".to_string(),
        };

        assert_eq!(comment1, comment2);
        assert_ne!(comment1, comment3);
    }

    #[test]
    fn test_pr_context_struct() {
        let context = PRContext {
            number: 42,
            title: "Test PR".to_string(),
            body: "This is a test PR description".to_string(),
            url: "https://github.com/owner/repo/pull/42".to_string(),
            unresolved_comments: vec![
                PRComment {
                    author: "reviewer1".to_string(),
                    body: "Please fix this".to_string(),
                    file_path: Some("src/lib.rs".to_string()),
                    line: Some(100),
                    id: 1,
                    url: "url1".to_string(),
                },
                PRComment {
                    author: "reviewer2".to_string(),
                    body: "Great work!".to_string(),
                    file_path: None,
                    line: None,
                    id: 2,
                    url: "url2".to_string(),
                },
            ],
        };

        assert_eq!(context.number, 42);
        assert_eq!(context.title, "Test PR");
        assert_eq!(context.unresolved_comments.len(), 2);
        assert_eq!(context.unresolved_comments[0].author, "reviewer1");
        assert_eq!(context.unresolved_comments[1].author, "reviewer2");
    }

    #[test]
    fn test_pr_context_result_success_variant() {
        let context = PRContext {
            number: 1,
            title: "Title".to_string(),
            body: "Body".to_string(),
            url: "url".to_string(),
            unresolved_comments: vec![],
        };
        let result = PRContextResult::Success(context);

        if let PRContextResult::Success(ctx) = result {
            assert_eq!(ctx.number, 1);
        } else {
            panic!("Expected Success variant");
        }
    }

    #[test]
    fn test_pr_context_result_no_comments_variant() {
        let result = PRContextResult::NoUnresolvedComments {
            number: 42,
            title: "Clean PR".to_string(),
            body: "All feedback addressed".to_string(),
            url: "url".to_string(),
        };

        if let PRContextResult::NoUnresolvedComments { number, title, .. } = result {
            assert_eq!(number, 42);
            assert_eq!(title, "Clean PR");
        } else {
            panic!("Expected NoUnresolvedComments variant");
        }
    }

    #[test]
    fn test_pr_context_result_error_variant() {
        let result = PRContextResult::Error("Something went wrong".to_string());

        if let PRContextResult::Error(msg) = result {
            assert_eq!(msg, "Something went wrong");
        } else {
            panic!("Expected Error variant");
        }
    }

    #[test]
    fn test_pr_context_clone() {
        let original = PRContext {
            number: 1,
            title: "Title".to_string(),
            body: "Body".to_string(),
            url: "url".to_string(),
            unresolved_comments: vec![PRComment {
                author: "user".to_string(),
                body: "comment".to_string(),
                file_path: None,
                line: None,
                id: 1,
                url: "url".to_string(),
            }],
        };
        let cloned = original.clone();
        assert_eq!(original.number, cloned.number);
        assert_eq!(
            original.unresolved_comments.len(),
            cloned.unresolved_comments.len()
        );
    }

    #[test]
    fn test_parse_review_comment_valid_json() {
        let json = serde_json::json!({
            "id": 12345,
            "body": "This needs fixing",
            "user": {
                "login": "reviewer"
            },
            "path": "src/main.rs",
            "line": 42,
            "html_url": "https://github.com/owner/repo/pull/1#discussion_r12345"
        });

        let comment = parse_review_comment(&json);
        assert!(comment.is_some());

        let comment = comment.unwrap();
        assert_eq!(comment.id, 12345);
        assert_eq!(comment.body, "This needs fixing");
        assert_eq!(comment.author, "reviewer");
        assert_eq!(comment.file_path, Some("src/main.rs".to_string()));
        assert_eq!(comment.line, Some(42));
    }

    #[test]
    fn test_parse_review_comment_missing_optional_fields() {
        let json = serde_json::json!({
            "id": 1,
            "body": "Comment",
            "user": {
                "login": "user"
            },
            "html_url": "url"
        });

        let comment = parse_review_comment(&json);
        assert!(comment.is_some());

        let comment = comment.unwrap();
        assert!(comment.file_path.is_none());
        assert!(comment.line.is_none());
    }

    #[test]
    fn test_parse_review_comment_uses_original_line_fallback() {
        // Some comments have original_line instead of line
        let json = serde_json::json!({
            "id": 1,
            "body": "Comment",
            "user": {
                "login": "user"
            },
            "path": "file.rs",
            "original_line": 50,
            "html_url": "url"
        });

        let comment = parse_review_comment(&json);
        assert!(comment.is_some());
        assert_eq!(comment.unwrap().line, Some(50));
    }

    #[test]
    fn test_parse_review_comment_missing_id_returns_none() {
        let json = serde_json::json!({
            "body": "Comment without ID",
            "user": {
                "login": "user"
            }
        });

        let comment = parse_review_comment(&json);
        assert!(comment.is_none());
    }

    #[test]
    fn test_parse_review_comment_missing_body_returns_none() {
        let json = serde_json::json!({
            "id": 1,
            "user": {
                "login": "user"
            }
        });

        let comment = parse_review_comment(&json);
        assert!(comment.is_none());
    }

    #[test]
    fn test_parse_conversation_comment_valid_json() {
        let json = serde_json::json!({
            "id": 67890,
            "body": "General feedback on the PR",
            "user": {
                "login": "commenter"
            },
            "html_url": "https://github.com/owner/repo/pull/1#issuecomment-67890"
        });

        let comment = parse_conversation_comment(&json);
        assert!(comment.is_some());

        let comment = comment.unwrap();
        assert_eq!(comment.id, 67890);
        assert_eq!(comment.body, "General feedback on the PR");
        assert_eq!(comment.author, "commenter");
        assert!(comment.file_path.is_none());
        assert!(comment.line.is_none());
    }

    #[test]
    fn test_parse_conversation_comment_missing_user() {
        let json = serde_json::json!({
            "id": 1,
            "body": "Comment",
            "html_url": "url"
        });

        let comment = parse_conversation_comment(&json);
        assert!(comment.is_some());
        assert_eq!(comment.unwrap().author, "unknown");
    }

    #[test]
    fn test_get_pr_description_returns_result() {
        // This test verifies the function runs without panicking
        // Actual outcome depends on system configuration
        let result = get_pr_description(99999);
        // Should return a Result (likely an error for non-existent PR)
        match result {
            Ok((title, body, url)) => {
                // If somehow successful, verify we got strings
                assert!(title.len() >= 0);
                assert!(body.len() >= 0);
                assert!(url.len() >= 0);
            }
            Err(_) => {
                // Expected - PR doesn't exist or gh not configured
            }
        }
    }

    #[test]
    fn test_get_unresolved_review_comments_returns_result() {
        // This test verifies the function runs without panicking
        let result = get_unresolved_review_comments(99999);
        match result {
            Ok(comments) => {
                // If successful, verify we got a vec
                assert!(comments.len() >= 0);
            }
            Err(_) => {
                // Expected - PR doesn't exist or gh not configured
            }
        }
    }

    #[test]
    fn test_get_conversation_comments_returns_result() {
        // This test verifies the function runs without panicking
        let result = get_conversation_comments(99999);
        match result {
            Ok(comments) => {
                // If successful, verify we got a vec
                assert!(comments.len() >= 0);
            }
            Err(_) => {
                // Expected - PR doesn't exist or gh not configured
            }
        }
    }

    #[test]
    fn test_gather_pr_context_returns_result() {
        // This test verifies the function runs without panicking
        let result = gather_pr_context(99999);
        match result {
            PRContextResult::Success(_) => {
                // Unlikely for non-existent PR, but valid
            }
            PRContextResult::NoUnresolvedComments { .. } => {
                // Possible if PR exists but has no comments
            }
            PRContextResult::Error(_) => {
                // Expected - PR doesn't exist or gh not configured
            }
        }
    }

    #[test]
    fn test_filter_unresolved_review_comments_empty_input() {
        // Empty input should return empty output
        let result = filter_unresolved_review_comments("owner", "repo", 1, vec![]);
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty());
    }

    // ========================================================================
    // US-003: Branch Context Tests
    // ========================================================================

    #[test]
    fn test_branch_context_struct() {
        let context = BranchContext {
            branch_name: "feature/test".to_string(),
            spec: None,
            spec_path: std::path::PathBuf::from("/path/to/spec.json"),
            commits: vec![],
        };

        assert_eq!(context.branch_name, "feature/test");
        assert!(context.spec.is_none());
        assert!(context.commits.is_empty());
    }

    #[test]
    fn test_branch_context_with_spec() {
        let spec = Spec {
            project: "test-project".to_string(),
            branch_name: "feature/test".to_string(),
            description: "Test description".to_string(),
            user_stories: vec![UserStory {
                id: "US-001".to_string(),
                title: "Test".to_string(),
                description: "Description".to_string(),
                acceptance_criteria: vec![],
                priority: 1,
                passes: false,
                notes: String::new(),
            }],
        };

        let context = BranchContext {
            branch_name: "feature/test".to_string(),
            spec: Some(spec),
            spec_path: std::path::PathBuf::from("/path/to/spec.json"),
            commits: vec![],
        };

        assert!(context.spec.is_some());
        assert_eq!(context.spec.as_ref().unwrap().project, "test-project");
    }

    #[test]
    fn test_branch_context_with_commits() {
        let commits = vec![git::CommitInfo {
            short_hash: "abc1234".to_string(),
            full_hash: "abc1234567890".to_string(),
            message: "Test commit".to_string(),
            author: "Author".to_string(),
            date: "2024-01-15".to_string(),
        }];

        let context = BranchContext {
            branch_name: "feature/test".to_string(),
            spec: None,
            spec_path: std::path::PathBuf::from("/path/to/spec.json"),
            commits,
        };

        assert_eq!(context.commits.len(), 1);
        assert_eq!(context.commits[0].short_hash, "abc1234");
    }

    #[test]
    fn test_branch_context_clone() {
        let context = BranchContext {
            branch_name: "feature/test".to_string(),
            spec: None,
            spec_path: std::path::PathBuf::from("/path/to/spec.json"),
            commits: vec![],
        };

        let cloned = context.clone();
        assert_eq!(context.branch_name, cloned.branch_name);
    }

    #[test]
    fn test_branch_context_result_variants() {
        // Test SuccessWithSpec variant
        let context = BranchContext {
            branch_name: "test".to_string(),
            spec: None,
            spec_path: std::path::PathBuf::from("/path"),
            commits: vec![],
        };
        let result = BranchContextResult::SuccessWithSpec(context.clone());
        if let BranchContextResult::SuccessWithSpec(ctx) = result {
            assert_eq!(ctx.branch_name, "test");
        } else {
            panic!("Expected SuccessWithSpec");
        }

        // Test SuccessNoSpec variant
        let result = BranchContextResult::SuccessNoSpec(context.clone());
        if let BranchContextResult::SuccessNoSpec(ctx) = result {
            assert_eq!(ctx.branch_name, "test");
        } else {
            panic!("Expected SuccessNoSpec");
        }

        // Test Error variant
        let result = BranchContextResult::Error("test error".to_string());
        if let BranchContextResult::Error(msg) = result {
            assert_eq!(msg, "test error");
        } else {
            panic!("Expected Error");
        }
    }

    #[test]
    fn test_expected_spec_path_format() {
        // Test branch name conversion
        let path = expected_spec_path("feature/pr-review");
        let path_str = path.to_string_lossy();
        // Should contain the sanitized branch name (/ replaced with -)
        assert!(path_str.contains("spec-feature-pr-review.json"));
    }

    #[test]
    fn test_expected_spec_path_simple_branch() {
        let path = expected_spec_path("main");
        let path_str = path.to_string_lossy();
        assert!(path_str.contains("spec-main.json"));
    }

    #[test]
    fn test_gather_branch_context_returns_result() {
        // This test verifies the function runs without panicking
        // The actual result depends on the git repo state
        let result = gather_branch_context(false);
        match result {
            BranchContextResult::SuccessWithSpec(ctx) => {
                assert!(!ctx.branch_name.is_empty());
                assert!(ctx.spec.is_some());
            }
            BranchContextResult::SuccessNoSpec(ctx) => {
                assert!(!ctx.branch_name.is_empty());
                assert!(ctx.spec.is_none());
            }
            BranchContextResult::Error(msg) => {
                // Valid if not in a git repo
                assert!(!msg.is_empty());
            }
        }
    }

    #[test]
    fn test_find_spec_for_branch_returns_result() {
        // This test verifies the function runs without panicking
        let result = find_spec_for_branch("nonexistent-branch-name");
        // Result should be Ok(None) for a branch with no spec
        match result {
            Ok(None) => {
                // Expected - no spec for this branch
            }
            Ok(Some((spec, path))) => {
                // Unlikely but valid if there's a matching spec
                assert!(!spec.project.is_empty());
                assert!(path.exists());
            }
            Err(_) => {
                // Could fail if config dir doesn't exist
            }
        }
    }

    #[test]
    fn test_print_branch_context_does_not_panic() {
        let context = BranchContext {
            branch_name: "feature/test".to_string(),
            spec: None,
            spec_path: std::path::PathBuf::from("/path/to/spec.json"),
            commits: vec![git::CommitInfo {
                short_hash: "abc1234".to_string(),
                full_hash: "abc1234567890".to_string(),
                message: "Test commit".to_string(),
                author: "Author".to_string(),
                date: "2024-01-15".to_string(),
            }],
        };

        print_branch_context(&context);
    }
}
